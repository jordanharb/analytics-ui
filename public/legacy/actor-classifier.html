<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>V2 Actor Management System - Admin</title>
    <script src="admin-auth.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .header-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .header-btn {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .header-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .search-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .search-btn {
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 15px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }

        .search-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .search-btn.active {
            background: linear-gradient(45deg, #f093fb 0%, #f5576c 100%);
        }

        .search-btn.custom {
            background: linear-gradient(45deg, #fa709a 0%, #fee140 100%);
        }

        .results-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .results-table th,
        .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .results-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #555;
            position: sticky;
            top: 0;
        }

        .results-table tr:hover {
            background: #f8f9fa;
        }

        .profile-link {
            color: #4facfe;
            text-decoration: none;
            font-weight: 500;
        }

        .profile-link:hover {
            text-decoration: underline;
        }

        .action-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin: 2px;
            transition: background 0.2s;
        }

        .action-btn:hover {
            background: #218838;
        }

        .action-btn.link {
            background: #6f42c1;
        }

        .action-btn.link:hover {
            background: #5a32a3;
        }

        .action-btn.add-username {
            background: #17a2b8;
        }

        .action-btn.add-username:hover {
            background: #138496;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
        }

        .modal-content {
            background: white;
            margin: 50px auto;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        /* Wider modal for edit actor */
        #edit-actor-modal .modal-content {
            max-width: 1200px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .form-group textarea {
            height: 80px;
            resize: vertical;
        }

        .form-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
            border-top: 2px solid #eee;
            padding-top: 20px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.2s;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #218838;
        }

        .actor-type-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        /* Actor linking styles */
        .actor-link-section {
            background: #f0f7ff;
            border: 2px dashed #4facfe;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }

        .linked-actors-list {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .linked-actor-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: white;
            border-radius: 4px;
            margin-bottom: 5px;
        }

        .linked-actor-info {
            flex: 1;
        }

        .relationship-select {
            width: 150px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 10px;
        }

        .remove-link-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .remove-link-btn:hover {
            background: #c82333;
        }

        /* Edit actor modal styles */
        .edit-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
        }

        .edit-tab {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            transition: all 0.2s;
        }

        .edit-tab:hover {
            color: #333;
            background: #f8f9fa;
        }

        .edit-tab.active {
            color: #4facfe;
            border-bottom-color: #4facfe;
        }

        .edit-tab-content {
            display: none;
            min-height: 300px;
        }

        .edit-tab-content.active {
            display: block;
        }

        .view-mode {
            position: relative;
        }

        .view-mode .form-group input:not(.editable),
        .view-mode .form-group select:not(.editable),
        .view-mode .form-group textarea:not(.editable) {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            cursor: default;
            pointer-events: none;
        }

        .edit-mode-toggle {
            position: absolute;
            top: 0;
            right: 0;
            background: #17a2b8;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .edit-mode-toggle:hover {
            background: #138496;
        }

        .edit-mode-toggle.editing {
            background: #28a745;
        }

        .edit-mode-toggle.editing:hover {
            background: #218838;
        }

        .actor-type-btn {
            padding: 15px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .actor-type-btn:hover {
            border-color: #4facfe;
            background: #f8f9ff;
        }

        .actor-type-btn.selected {
            border-color: #4facfe;
            background: #4facfe;
            color: white;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .no-results {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 15px;
            border: 1px solid #c3e6cb;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 15px;
            border: 1px solid #f5c6cb;
        }

        .bio-preview {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .priority-score {
            font-weight: bold;
            color: #28a745;
        }

        .existing-actors-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .existing-actors-table th,
        .existing-actors-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .existing-actors-table tr:hover {
            background: #f8f9fa;
            cursor: pointer;
        }

        .existing-actors-table tr.selected {
            background: #e3f2fd;
        }

        .search-filter {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding: 15px;
            border-top: 1px solid #eee;
        }

        .load-more-btn {
            background: #6f42c1;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .load-more-btn:hover {
            background: #5a32a3;
        }

        .load-more-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .load-more-btn.loading {
            background: #9e9e9e;
            cursor: wait;
        }

        .pagination-info {
            color: #666;
            font-size: 14px;
        }

        .checkbox-label {
            display: flex !important;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            margin-bottom: 8px;
        }

        .org-selection-container {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            background: #fafafa;
        }

        .selected-org-item {
            margin: 5px 0;
            padding: 8px;
            background: #e3f2fd;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #90caf9;
        }

        .selected-org-item input {
            width: 150px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 12px;
        }

        .form-grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        /* Global search styling */
        #global-search:focus {
            border-color: #4facfe !important;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        #clear-search-btn:hover {
            background: #545b62;
        }

        /* Organization search specific styling */
        .org-search-status {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            padding: 5px;
            background: #f8f9fa;
            border-radius: 3px;
        }

        .org-search-loading {
            color: #007bff;
        }

        .org-search-results {
            color: #28a745;
        }

        .org-search-error {
            color: #dc3545;
            background: #f8d7da;
        }

        /* Filter builder styling */
        .filter-builder {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .filter-option {
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .filter-remove {
            float: right;
            color: #dc3545;
            cursor: pointer;
            font-weight: bold;
        }

        .filter-remove:hover {
            color: #a02622;
        }

        /* Username management styling */
        .username-list {
            margin-top: 10px;
        }

        .username-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 5px;
        }

        .username-info {
            flex: 1;
        }

        .username-actions {
            display: flex;
            gap: 5px;
        }

        .username-badge {
            display: inline-block;
            padding: 2px 8px;
            background: #e3f2fd;
            color: #1976d2;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 8px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
        }

        .tab {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            transition: all 0.2s;
        }

        .tab:hover {
            color: #333;
            background: #f8f9fa;
        }

        .tab.active {
            color: #4facfe;
            border-bottom-color: #4facfe;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎯 V2 Actor Management System</h1>
            <p>Efficiently process unknown actors with smart categorization and automated linking</p>
            

            <div class="header-actions">
                <button class="header-btn" onclick="openCreateActorModal()">
                    ➕ Create New Actor
                </button>
                <button class="header-btn" onclick="openCreateViewModal()">
                    🎨 Create Custom View
                </button>
                <button class="header-btn" onclick="openMergeDuplicatesModal()">
                    🔀 Merge Duplicates
                </button>
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" id="unknown-tab-btn">Unknown Actors</button>
            <button class="tab" id="existing-tab-btn">Existing Actors</button>
        </div>

        <div id="unknown-tab" class="tab-content active">
            <input type="text" 
                   id="unknown-actors-search" 
                   class="search-filter"
                   placeholder="Search unknown actors by username, name, or bio..." 
                   onkeyup="debouncedUnknownActorSearch()"
                   onkeydown="if(event.key==='Enter') performUnknownActorSearch()"
                   style="width: 100%; margin-bottom: 20px;">
            
            <div class="search-options" id="filter-buttons">
                <!-- Dynamic filter buttons will be loaded here -->
            </div>
            
            <!-- Network Strength Filter -->
            <div class="network-filter-section" style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
                <h4 style="margin: 0 0 15px 0; color: #495057;">🔗 Network Connection Filter</h4>
                <div style="display: flex; gap: 15px; flex-wrap: wrap; align-items: center;">
                    <select id="network-filter-type" onchange="toggleNetworkFilter()" style="padding: 8px; border-radius: 4px; border: 1px solid #ced4da;">
                        <option value="none">No Network Filter</option>
                        <option value="connected_to">Strongly Connected To...</option>
                        <option value="mentioned_by">Frequently Mentioned By...</option>
                        <option value="mentions">Frequently Mentions...</option>
                        <option value="mutual">Mutual Connections With...</option>
                    </select>
                    
                    <div id="network-target-selector" style="display:none; gap: 10px; align-items: center; position: relative;">
                        <div style="position: relative; min-width: 400px;">
                            <input type="text" 
                                   id="network-target-search" 
                                   placeholder="Search for actor by name or enter @username..."
                                   oninput="searchActorsForNetwork(this.value)"
                                   onblur="setTimeout(() => hideActorResults(), 200)"
                                   style="padding: 8px; border-radius: 4px; border: 1px solid #ced4da; width: 100%;">
                            <div id="actor-search-results" 
                                 style="display: none; position: absolute; top: 100%; left: 0; right: 0; 
                                        background: white; border: 1px solid #ced4da; border-top: none; 
                                        border-radius: 0 0 4px 4px; max-height: 300px; overflow-y: auto; 
                                        z-index: 1000; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            </div>
                        </div>
                        <input type="hidden" id="network-target-actor-id" value="">
                        <input type="hidden" id="network-target-handle" value="">
                    </div>
                    
                    <div id="network-strength-controls" style="display:none; align-items: center; gap: 10px;">
                        <label style="margin: 0;">Min interactions:</label>
                        <input type="range" 
                               id="network-strength-threshold" 
                               min="1" max="100" value="5"
                               oninput="updateNetworkStrengthLabel()"
                               style="width: 150px;">
                        <span id="strength-value" style="min-width: 80px; font-weight: 600; color: #6f42c1;">5+ mentions</span>
                    </div>
                    
                    <button id="apply-network-filter-btn" 
                            onclick="applyNetworkFilter()" 
                            style="display:none; padding: 8px 16px; background: #6f42c1; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">
                        Apply Filter
                    </button>
                    
                    <button id="clear-network-filter-btn" 
                            onclick="clearNetworkFilter()" 
                            style="display:none; padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        Clear
                    </button>
                </div>
                <div id="network-filter-status" style="margin-top: 10px; padding: 10px; background: #e7f3ff; border-radius: 4px; display: none;">
                    <span id="network-filter-message"></span>
                </div>
            </div>

            <div class="results-container" id="results-container" style="display: none;">
                <h3 id="results-title">Results</h3>
                <div id="results-content">
                    <div class="loading">Loading...</div>
                </div>
            </div>
        </div>

        <div id="existing-tab" class="tab-content">
            <div class="results-container">
                <div id="actor-list-section">
                    <h3>Existing Actors</h3>
                    <input type="text" class="search-filter" id="existing-actors-main-search" 
                           placeholder="Search existing actors..." 
                           onkeyup="debouncedSearchExistingActors()">
                    
                    <!-- Advanced Search Button for Main Tab -->
                    <button class="btn btn-secondary" onclick="toggleMainAdvancedSearch()" style="margin: 10px 0; padding: 8px 15px; font-size: 13px; background: linear-gradient(45deg, #6f42c1 0%, #8e44ad 100%);">
                        🔍 Advanced Search ▼
                    </button>
                    
                    <!-- Advanced Search Panel for Main Tab -->
                    <div id="main-advanced-search-fields" style="display: none; background: #f9f9f9; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h4 style="margin: 0;">Advanced Actor Search</h4>
                            <div>
                                <button class="btn btn-primary" onclick="performMainAdvancedSearch()" style="padding: 5px 15px; font-size: 12px;">
                                    🔍 Search
                                </button>
                                <button class="btn btn-secondary" onclick="clearMainAdvancedSearch()" style="padding: 5px 15px; font-size: 12px; margin-left: 5px;">
                                    ✕ Clear
                                </button>
                            </div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>
                                <label style="font-size: 12px;">Name:</label>
                                <input type="text" id="main-adv-search-name" class="search-filter" placeholder="Actor name..." style="width: 100%;">
                            </div>
                            <div>
                                <label style="font-size: 12px;">About/Bio:</label>
                                <input type="text" id="main-adv-search-about" class="search-filter" placeholder="Description..." style="width: 100%;">
                            </div>
                            <div>
                                <label style="font-size: 12px;">City:</label>
                                <input type="text" id="main-adv-search-city" class="search-filter" placeholder="City name..." style="width: 100%;">
                            </div>
                            <div>
                                <label style="font-size: 12px;">State:</label>
                                <input type="text" id="main-adv-search-state" class="search-filter" placeholder="State..." style="width: 100%;">
                            </div>
                            <div>
                                <label style="font-size: 12px;">Region:</label>
                                <input type="text" id="main-adv-search-region" class="search-filter" placeholder="Region..." style="width: 100%;">
                            </div>
                            <div>
                                <label style="font-size: 12px;">Actor Type:</label>
                                <select id="main-adv-search-type" class="search-filter" style="width: 100%; padding: 5px;">
                                    <option value="">All Types</option>
                                    <option value="person">Person</option>
                                    <option value="organization">Organization</option>
                                    <option value="chapter">Chapter</option>
                                </select>
                            </div>
                        </div>
                        
                        <!-- Actor Linking Search -->
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                            <h5 style="margin-top: 0; margin-bottom: 10px; color: #6f42c1;">🔗 Actor Relationships</h5>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <div>
                                    <label style="font-size: 12px;">Linked to Actor:</label>
                                    <div style="position: relative;">
                                        <input type="text" 
                                               id="main-adv-search-linked-actor" 
                                               placeholder="Search for actor..."
                                               oninput="searchMainLinkedActorSuggestions(this.value)"
                                               style="width: 100%; padding: 5px;">
                                        <input type="hidden" id="main-adv-search-linked-actor-id">
                                        <div id="main-linked-actor-suggestions" 
                                             style="display: none; position: absolute; top: 100%; left: 0; right: 0; 
                                                    background: white; border: 1px solid #ddd; border-radius: 4px; 
                                                    max-height: 200px; overflow-y: auto; z-index: 1000; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <label style="font-size: 12px;">Relationship Type:</label>
                                    <select id="main-adv-search-relationship" class="search-filter" style="width: 100%; padding: 5px;">
                                        <option value="">Any Relationship</option>
                                        <option value="none" style="background: #fff3cd; color: #856404;">🚫 No Relationships (Orphaned)</option>
                                        <option value="employment">Employment</option>
                                        <option value="membership">Membership</option>
                                        <option value="leadership">Leadership</option>
                                        <option value="family">Family</option>
                                        <option value="partnership">Partnership</option>
                                        <option value="other">Other</option>
                                    </select>
                                </div>
                            </div>
                            <div style="margin-top: 10px;">
                                <label style="font-size: 12px;">
                                    <input type="checkbox" id="main-adv-search-bidirectional" checked>
                                    Include bidirectional relationships (both directions)
                                </label>
                            </div>
                        </div>
                        
                        <!-- Active Search Indicator -->
                        <div id="main-active-search-indicator" style="display: none; margin-top: 10px; padding: 10px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 4px; color: #155724;">
                            <strong>🔍 Active Search:</strong> <span id="main-active-search-summary"></span>
                        </div>
                    </div>
                    
                    <div class="actor-type-selector">
                        <div class="actor-type-btn selected" onclick="filterExistingActorType('all')">
                            <h4>🔍 All</h4>
                        </div>
                        <div class="actor-type-btn" onclick="filterExistingActorType('person')">
                            <h4>👤 People</h4>
                        </div>
                        <div class="actor-type-btn" onclick="filterExistingActorType('organization')">
                            <h4>🏢 Organizations</h4>
                        </div>
                        <div class="actor-type-btn" onclick="filterExistingActorType('chapter')">
                            <h4>🏫 Chapters</h4>
                        </div>
                    </div>

                    <div id="existing-actors-main-list">
                        <div class="loading">Loading existing actors...</div>
                    </div>
                </div>
                
                <!-- Inline Edit Section -->
                <div id="inline-edit-section" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 20px; background: white; border-radius: 8px;">
                        <h2 id="editing-actor-name" style="color: #333;">Edit Actor</h2>
                        <button class="btn btn-secondary" onclick="closeInlineEdit()">← Back to Actor List</button>
                    </div>
                    
                    <!-- All sections displayed sequentially -->
                    
                    <!-- Details Section -->
                    <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3>Actor Details</h3>
                            <button class="edit-mode-toggle" onclick="toggleEditMode('details')">Edit</button>
                        </div>
                        <div class="view-mode" id="details-view-mode">
                            <div id="actor-details-form">
                                <!-- Will be populated dynamically based on actor type -->
                            </div>
                            <div class="form-actions" style="display: none;" id="details-save-section">
                                <button class="btn btn-secondary" onclick="cancelEditMode('details')">Cancel</button>
                                <button class="btn btn-primary" onclick="saveActorDetails()">Save Changes</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- JSONB Data Section -->
                    <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3>Additional Data (JSONB)</h3>
                            <button class="edit-mode-toggle" onclick="toggleEditMode('jsonb')">Edit</button>
                        </div>
                        <div class="view-mode" id="jsonb-view-mode">
                            <div id="jsonb-data-fields">
                                <!-- Will be populated with individual JSONB fields -->
                            </div>
                            <div class="form-actions" style="display: none;" id="jsonb-save-section">
                                <button class="btn btn-secondary" onclick="cancelEditMode('jsonb')">Cancel</button>
                                <button class="btn btn-primary" onclick="saveJsonbData()">Save JSONB Data</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Usernames Section -->
                    <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h3>Social Media Usernames</h3>
                        <div id="actor-usernames-list"></div>
                        
                        <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                            <h4>Add New Username</h4>
                            <div class="form-grid-2">
                                <div class="form-group">
                                    <label>Platform</label>
                                    <select id="new-username-platform">
                                        <option value="twitter">Twitter/X</option>
                                        <option value="instagram">Instagram</option>
                                        <option value="tiktok">TikTok</option>
                                        <option value="youtube">YouTube</option>
                                        <option value="telegram">Telegram</option>
                                        <option value="facebook">Facebook</option>
                                        <option value="truth_social">Truth Social</option>
                                        <option value="gab">Gab</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Username</label>
                                    <input type="text" id="new-username-value" placeholder="username">
                                </div>
                            </div>
                            <label class="checkbox-label">
                                <input type="checkbox" id="new-username-verified">
                                Verified Account
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" id="new-username-scrape" checked>
                                Should Scrape
                            </label>
                            <button class="btn btn-primary" onclick="addNewUsername()">Add Username</button>
                        </div>
                    </div>
                    
                    <!-- Relationships Section -->
                    <div style="background: white; padding: 25px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <h2 style="color: #333; margin-bottom: 20px; font-size: 24px;">Relationships</h2>
                        
                        <!-- Edit/Save buttons for relationships -->
                        <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <button id="relationships-edit-toggle" class="btn btn-primary" onclick="toggleEditMode('relationships')" style="padding: 10px 20px; font-size: 16px;">
                                    Edit Relationships
                                </button>
                            </div>
                            <div id="relationships-save-section" style="display: none; gap: 10px;">
                                <button class="btn btn-secondary" onclick="cancelEditMode('relationships')" style="padding: 10px 20px; font-size: 16px;">
                                    Cancel
                                </button>
                                <button class="btn btn-success" onclick="saveRelationships()" style="padding: 10px 20px; font-size: 16px; background: #28a745;">
                                    Save Changes
                                </button>
                            </div>
                        </div>
                        
                        <div id="relationships-view-mode" class="view-mode">
                            <div id="actor-links-list" style="font-size: 16px;">
                                <div class="loading">Loading relationships...</div>
                            </div>
                        </div>
                        
                        <div id="add-relationship-section" style="display: none; margin-top: 20px; padding: 20px; background: #f0f7ff; border-radius: 8px;">
                            <h3 style="font-size: 20px; margin-bottom: 15px;">Add New Relationship</h3>
                            <div class="form-group">
                                <label>Search for Actor to Link</label>
                                <input type="text" id="link-actor-search" placeholder="Search actors..." onkeyup="debouncedSearchForLinking()">
                            </div>
                            <div id="link-search-results" style="max-height: 200px; overflow-y: auto; margin: 10px 0;"></div>
                            <div id="selected-link-actor" style="display: none; margin: 10px 0; padding: 10px; background: #e3f2fd; border-radius: 4px;">
                                <strong>Selected:</strong> <span id="selected-link-name"></span>
                                <div class="form-group" style="margin-top: 10px;">
                                    <label>Relationship Type</label>
                                    <select id="link-relationship-type">
                                        <!-- Options will be populated based on actor type -->
                                    </select>
                                </div>
                                <button class="btn btn-primary" onclick="addActorLink()">Add Link</button>
                                <button class="btn btn-secondary" onclick="clearLinkSelection()">Cancel</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Promote Actor Modal -->
    <div id="promote-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Promote Unknown Actor</h2>
                <span class="close" onclick="closeModal('promote-modal')">&times;</span>
            </div>

            <div id="promote-content">
                <div class="actor-type-selector" id="actor-type-selector">
                    <!-- Actor types will be dynamically populated from V2 schema -->
                    <div class="loading-spinner">Loading actor types...</div>
                </div>

                <div id="promote-form" style="display: none;">
                    <!-- Form will be populated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <!-- Link to Existing Actor Modal -->
    <div id="link-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Link to Existing Actor</h2>
                <span class="close" onclick="closeModal('link-modal')">&times;</span>
            </div>

            <div id="link-content">
                <!-- Unknown Actor Info Display -->
                <div id="unknown-actor-info" style="background: #f5f5f5; padding: 15px; margin-bottom: 20px; border-radius: 8px; border-left: 4px solid #4facfe;">
                    <!-- Will be populated when modal opens -->
                </div>
                
                <!-- Actor Type Filter Buttons -->
                <div class="actor-type-selector" style="margin-bottom: 15px;">
                    <button class="actor-type-btn selected" onclick="filterLinkActorType('all')" data-type="all">
                        <span>🌐 All Types</span>
                    </button>
                    <button class="actor-type-btn" onclick="filterLinkActorType('person')" data-type="person">
                        <span>👤 Person</span>
                    </button>
                    <button class="actor-type-btn" onclick="filterLinkActorType('organization')" data-type="organization">
                        <span>🏢 Organization</span>
                    </button>
                    <button class="actor-type-btn" onclick="filterLinkActorType('chapter')" data-type="chapter">
                        <span>🏫 Chapter</span>
                    </button>
                </div>
                
                <!-- Search Box -->
                <div class="form-group">
                    <input type="text" class="search-filter" id="actor-search-input" 
                           placeholder="Search by name, username, city, or state..." 
                           oninput="searchActorsForLink(this.value)">
                    <button class="btn btn-secondary" onclick="toggleAdvancedSearch()" style="margin-top: 10px; padding: 5px 10px; font-size: 12px;">
                        Advanced Search ▼
                    </button>
                </div>
                
                <!-- Advanced Search Fields (initially hidden) -->
                <div id="advanced-search-fields" style="display: none; background: #f9f9f9; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="margin: 0;">Advanced Search</h4>
                        <div>
                            <button class="btn btn-primary" onclick="performAdvancedActorSearch()" style="padding: 5px 15px; font-size: 12px;">
                                🔍 Search
                            </button>
                            <button class="btn btn-secondary" onclick="clearAdvancedSearch()" style="padding: 5px 15px; font-size: 12px; margin-left: 5px;">
                                ✕ Clear
                            </button>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div>
                            <label style="font-size: 12px;">Name:</label>
                            <input type="text" id="adv-search-name" class="search-filter" placeholder="Actor name..." style="width: 100%;">
                        </div>
                        <div>
                            <label style="font-size: 12px;">About/Bio:</label>
                            <input type="text" id="adv-search-about" class="search-filter" placeholder="Description..." style="width: 100%;">
                        </div>
                        <div>
                            <label style="font-size: 12px;">City:</label>
                            <input type="text" id="adv-search-city" class="search-filter" placeholder="City name..." style="width: 100%;">
                        </div>
                        <div>
                            <label style="font-size: 12px;">State:</label>
                            <input type="text" id="adv-search-state" class="search-filter" placeholder="State..." style="width: 100%;">
                        </div>
                        <div>
                            <label style="font-size: 12px;">Region:</label>
                            <input type="text" id="adv-search-region" class="search-filter" placeholder="Region..." style="width: 100%;">
                        </div>
                        <div>
                            <label style="font-size: 12px;">Actor Type:</label>
                            <select id="adv-search-type" class="search-filter" style="width: 100%; padding: 5px;">
                                <option value="">All Types</option>
                                <option value="person">Person</option>
                                <option value="organization">Organization</option>
                                <option value="chapter">Chapter</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Actor Linking Search -->
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <h5 style="margin-top: 0; margin-bottom: 10px; color: #6f42c1;">🔗 Actor Relationships</h5>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>
                                <label style="font-size: 12px;">Linked to Actor:</label>
                                <div style="position: relative;">
                                    <input type="text" 
                                           id="adv-search-linked-actor" 
                                           placeholder="Search for actor..."
                                           oninput="searchLinkedActorSuggestions(this.value)"
                                           style="width: 100%; padding: 5px;">
                                    <input type="hidden" id="adv-search-linked-actor-id">
                                    <div id="linked-actor-suggestions" 
                                         style="display: none; position: absolute; top: 100%; left: 0; right: 0; 
                                                background: white; border: 1px solid #ddd; border-radius: 4px; 
                                                max-height: 200px; overflow-y: auto; z-index: 1000; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                    </div>
                                </div>
                                <div id="selected-linked-actors" style="margin-top: 5px;"></div>
                            </div>
                            <div>
                                <label style="font-size: 12px;">Relationship Type:</label>
                                <select id="adv-search-relationship" class="search-filter" style="width: 100%; padding: 5px;">
                                    <option value="">Any Relationship</option>
                                    <option value="employment">Employment</option>
                                    <option value="membership">Membership</option>
                                    <option value="leadership">Leadership</option>
                                    <option value="family">Family</option>
                                    <option value="partnership">Partnership</option>
                                    <option value="other">Other</option>
                                </select>
                            </div>
                        </div>
                        <div style="margin-top: 10px;">
                            <label style="font-size: 12px;">
                                <input type="checkbox" id="adv-search-bidirectional" checked>
                                Include bidirectional relationships (both directions)
                            </label>
                        </div>
                    </div>
                    
                    <!-- Custom Fields -->
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <h5 style="margin-top: 0; margin-bottom: 10px; color: #17a2b8;">📝 Custom Fields</h5>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>
                                <label style="font-size: 12px;">School/Institution:</label>
                                <input type="text" id="adv-search-school" class="search-filter" placeholder="School name..." style="width: 100%;">
                            </div>
                            <div>
                                <label style="font-size: 12px;">Role Category:</label>
                                <input type="text" id="adv-search-role" class="search-filter" placeholder="Role..." style="width: 100%;">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Active Search Indicator -->
                    <div id="active-search-indicator" style="display: none; margin-top: 10px; padding: 10px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 4px; color: #155724;">
                        <strong>🔍 Active Search:</strong> <span id="active-search-summary"></span>
                    </div>
                </div>
                
                <!-- Suggestions Section (initially hidden) -->
                <div id="link-suggestions" style="display: none; margin-bottom: 15px;">
                    <!-- Suggestions will be added here -->
                </div>
                
                <!-- Actor List Table -->
                <div class="form-group">
                    <label>Select Actor to Link:</label>
                    <div id="link-actors-list" style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;">
                        <table class="existing-actors-table" style="width: 100%;">
                            <thead>
                                <tr>
                                    <th>Type</th>
                                    <th>Name</th>
                                    <th>Location</th>
                                    <th>Details</th>
                                </tr>
                            </thead>
                            <tbody id="link-actors-tbody">
                                <tr><td colspan="4" style="text-align: center; padding: 20px;">Loading actors...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- Selected Actor Preview -->
                <div id="actor-preview" style="margin-top: 15px; padding: 10px; border: 2px solid #4facfe; border-radius: 5px; background: #f0f7ff; display: none;">
                    <!-- Actor preview will be shown here -->
                </div>

                <div class="form-actions">
                    <button class="btn btn-secondary" onclick="closeModal('link-modal')">Cancel</button>
                    <button class="btn btn-primary" id="link-actor-button" onclick="confirmLinkToExisting()" disabled>
                        Link to Selected Actor
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create New Actor Modal -->
    <div id="create-actor-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Create New Actor</h2>
                <span class="close" onclick="closeModal('create-actor-modal')">&times;</span>
            </div>

            <div id="create-actor-content">
                <div class="actor-type-selector">
                    <div class="actor-type-btn" onclick="selectNewActorType('person')">
                        <h4>👤 Person</h4>
                        <p>Individual actor</p>
                    </div>
                    <div class="actor-type-btn" onclick="selectNewActorType('organization')">
                        <h4>🏢 Organization</h4>
                        <p>Company or group</p>
                    </div>
                    <div class="actor-type-btn" onclick="selectNewActorType('chapter')">
                        <h4>🏫 Chapter</h4>
                        <p>Local chapter</p>
                    </div>
                </div>

                <div id="create-actor-form" style="display: none;">
                    <!-- Form will be populated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Actor Modal -->
    <div id="edit-actor-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Edit Actor</h2>
                <span class="close" onclick="closeModal('edit-actor-modal')">&times;</span>
            </div>

            <div id="edit-actor-content">
                <input type="text" class="search-filter" id="edit-actor-search" 
                       placeholder="Search actors to edit..." 
                       onkeyup="debouncedSearchActorsForEdit()">
                
                <div id="edit-actors-list">
                    <div class="loading">Loading actors...</div>
                </div>

                <div id="actor-edit-section" style="display: none; margin-top: 20px;">
                    <h3 id="selected-edit-actor-name"></h3>
                    
                    <div class="edit-tabs">
                        <button class="edit-tab active" onclick="switchEditTab('details', event)">Details</button>
                        <button class="edit-tab" onclick="switchEditTab('usernames', event)">Usernames</button>
                        <button class="edit-tab" onclick="switchEditTab('links', event)">Relationships</button>
                    </div>
                    
                    <div id="details-tab" class="edit-tab-content active">
                        <div class="view-mode" id="details-view-mode">
                            <button class="edit-mode-toggle" onclick="toggleEditMode('details')">Edit</button>
                            <div id="actor-details-form">
                                <!-- Will be populated dynamically based on actor type -->
                            </div>
                            <div class="form-actions" style="display: none;" id="details-save-section">
                                <button class="btn btn-secondary" onclick="cancelEditMode('details')">Cancel</button>
                                <button class="btn btn-primary" onclick="saveActorDetails()">Save Changes</button>
                            </div>
                        </div>
                    </div>
                    
                    <div id="usernames-tab" class="edit-tab-content">
                        <div id="actor-usernames-list"></div>
                        
                        <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                            <h4>Add New Username</h4>
                            <div class="form-grid-2">
                                <div class="form-group">
                                    <label>Platform</label>
                                    <select id="new-username-platform">
                                        <option value="twitter">Twitter/X</option>
                                        <option value="instagram">Instagram</option>
                                        <option value="tiktok">TikTok</option>
                                        <option value="youtube">YouTube</option>
                                        <option value="telegram">Telegram</option>
                                        <option value="facebook">Facebook</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Username</label>
                                    <input type="text" id="new-username-value" placeholder="username">
                                </div>
                            </div>
                            <label class="checkbox-label">
                                <input type="checkbox" id="new-username-verified">
                                Verified Account
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" id="new-username-scrape" checked>
                                Should Scrape
                            </label>
                            <button class="btn btn-primary" onclick="addNewUsername()">Add Username</button>
                        </div>
                    </div>
                    
                    <div id="links-tab" class="edit-tab-content">
                        <div id="actor-links-list">
                            <div class="loading">Loading actor links...</div>
                        </div>
                        
                        <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                            <h4>Add Actor Link</h4>
                            <div class="form-group">
                                <label>Search for Actor to Link</label>
                                <input type="text" id="link-actor-search" placeholder="Search actors..." onkeyup="debouncedSearchForLinking()">
                            </div>
                            <div id="link-search-results" style="max-height: 200px; overflow-y: auto; margin: 10px 0;"></div>
                            <div id="selected-link-actor" style="display: none; margin: 10px 0; padding: 10px; background: #e3f2fd; border-radius: 4px;">
                                <strong>Selected:</strong> <span id="selected-link-name"></span>
                                <div class="form-group" style="margin-top: 10px;">
                                    <label>Relationship Type</label>
                                    <select id="link-relationship-type">
                                        <!-- Options will be populated based on actor type -->
                                    </select>
                                </div>
                                <button class="btn btn-primary" onclick="addActorLink()">Add Link</button>
                                <button class="btn btn-secondary" onclick="clearLinkSelection()">Cancel</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Custom View Modal -->
    <div id="create-view-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Create Custom Filter View</h2>
                <span class="close" onclick="closeModal('create-view-modal')">&times;</span>
            </div>

            <div id="create-view-content">
                <div id="view-message"></div>
                
                <div class="form-group">
                    <label>View Name</label>
                    <input type="text" id="view-name" placeholder="My Custom Filter">
                </div>
                
                <div class="form-group">
                    <label>Description</label>
                    <input type="text" id="view-description" placeholder="Description of what this view shows">
                </div>
                
                <div class="form-group">
                    <label>Icon (Emoji)</label>
                    <input type="text" id="view-icon" value="🔍" maxlength="2">
                </div>
                
                <div class="form-group">
                    <label>Filter Type</label>
                    <select id="filter-type" onchange="updateFilterOptions()">
                        <option value="keyword">Keyword Search</option>
                        <option value="platform">Platform</option>
                        <option value="date_range">Date Range</option>
                        <option value="mention_count">Mention Count</option>
                        <option value="verified">Verification Status</option>
                        <option value="combined">Combined Filters</option>
                    </select>
                </div>
                
                <div id="filter-options">
                    <!-- Dynamic options based on filter type -->
                </div>

                <div id="combined-filters" class="filter-builder" style="display: none;">
                    <h4>Combined Filters</h4>
                    <div id="filter-list"></div>
                    <button class="btn btn-secondary" onclick="addFilter()">Add Filter</button>
                </div>
                
                <div class="form-actions">
                    <button class="btn btn-secondary" onclick="closeModal('create-view-modal')">Cancel</button>
                    <button class="btn btn-primary" onclick="saveCustomView()">Save View</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Merge Duplicates Modal -->
    <div id="merge-duplicates-modal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2>🔀 Merge Duplicate Actors</h2>
                <span class="close" onclick="closeModal('merge-duplicates-modal')">&times;</span>
            </div>
            <div id="merge-duplicates-content">
                <div style="margin-bottom: 20px;">
                    <p style="color: #666; margin-bottom: 15px;">
                        Find and merge duplicate actors. Select a group of duplicates, choose the master record, and merge them together.
                    </p>
                    
                    <!-- Search Controls -->
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <input type="text" 
                               id="duplicate-search" 
                               placeholder="Search for actors by name or username..." 
                               style="flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 5px;"
                               oninput="searchDuplicates()">
                        <button class="btn btn-primary" onclick="findDuplicates()">
                            🔍 Find All Duplicates
                        </button>
                    </div>
                    
                    <!-- Actor Type Filter -->
                    <div class="actor-type-selector" style="margin-bottom: 15px;">
                        <button class="actor-type-btn selected" onclick="filterDuplicateType('all')" data-type="all">
                            <span>🌐 All Types</span>
                        </button>
                        <button class="actor-type-btn" onclick="filterDuplicateType('person')" data-type="person">
                            <span>👤 Person</span>
                        </button>
                        <button class="actor-type-btn" onclick="filterDuplicateType('organization')" data-type="organization">
                            <span>🏢 Organization</span>
                        </button>
                        <button class="actor-type-btn" onclick="filterDuplicateType('chapter')" data-type="chapter">
                            <span>🏫 Chapter</span>
                        </button>
                    </div>
                </div>
                
                <!-- Duplicate Groups List -->
                <div id="duplicate-groups" style="max-height: 400px; overflow-y: auto;">
                    <!-- Groups will be loaded here -->
                </div>
                
                <!-- Merge Action Area -->
                <div id="merge-action-area" style="display: none; margin-top: 20px; padding: 15px; border: 2px solid #4facfe; border-radius: 8px; background: #f0f7ff;">
                    <h3 style="margin-bottom: 10px;">Selected Group for Merge</h3>
                    <div id="selected-merge-group">
                        <!-- Selected actors will be shown here -->
                    </div>
                    <div style="margin-top: 15px;">
                        <p style="margin-bottom: 10px;"><strong>Select Master Actor:</strong> (all others will be merged into this one)</p>
                        <select id="master-actor-select" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="">Select master actor...</option>
                        </select>
                    </div>
                    <div class="form-actions" style="margin-top: 15px;">
                        <button class="btn btn-secondary" onclick="cancelMerge()">Cancel</button>
                        <button class="btn btn-primary" onclick="executeMerge()" style="background: #ff4444;">
                            🔀 Execute Merge
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Supabase configuration - using direct REST API calls (no CDN dependencies)
        const SUPABASE_URL = 'https://djzrlccihwqxtjkytcph.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRqenJsY2NpaHdxeHRqa3l0Y3BoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE5MzcwMDEsImV4cCI6MjA2NzUxMzAwMX0.ZfXHyQExHbIRLBHbw77KaHd2dKupsBhPAKz-zBFkSUQ';

        let currentSearchType = null;
        let currentUnknownActor = null;
        let selectedActorType = null;
        let existingActors = [];
        let filteredExistingActors = [];
        let selectedExistingActor = null;
        let linkSearchOffset = 0;
        let linkSearchLimit = 50;
        let hasMoreLinkResults = false;
        let currentLinkSearchTerm = '';
        let isLoadingLinkSearch = false;
        let organizations = [];
        let existingRoleCategories = [];
        let searchTimeout = null;
        let globalSearchTimeout = null;
        let orgSearchTimeout = null;
        let customViews = [];
        let currentView = null;
        let selectedActorForUsername = null;
        let selectedActorForEdit = null;
        let selectedLinkedActors = [];
        let editMode = {
            details: false,
            usernames: false,
            links: false,
            relationships: false
        };
        let tempSelectedLinkActor = null;
        let linkSearchTimeout = null;
        
        // Pagination variables
        let currentPage = 0;
        let pageSize = 100;
        let hasMoreActors = true;
        let currentActorTypeFilter = 'all';
        
        // Main unknown actors pagination variables
        let currentUnknownActorsPage = 0;
        let unknownActorsPageSize = 50;
        
        // Network filter state
        let networkFilterActive = false;
        let networkFilterResults = [];
        let hasMoreUnknownActors = true;
        let currentUnknownActors = [];
        let isLoadingMore = false;

        // Direct Supabase REST API functions (no external dependencies)
        async function supabaseRequest(endpoint, options = {}) {
            const url = `${SUPABASE_URL}/rest/v1/${endpoint}`;
            const headers = {
                'apikey': SUPABASE_KEY,
                'Authorization': `Bearer ${SUPABASE_KEY}`,
                'Content-Type': 'application/json',
                'Prefer': 'return=representation',
                ...(options.headers || {})
            };
            
            const config = {
                ...options,
                headers
            };
            
            console.log(`🌐 API Request: ${options.method || 'GET'} ${url}`);
            
            const response = await fetch(url, config);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error(`❌ API Error (${response.status}):`, errorText);
                throw new Error(`API Error ${response.status}: ${errorText}`);
            }
            
            const data = await response.json();
            console.log(`✅ API Success:`, data);
            return data;
        }

        // Call Supabase stored procedures/functions
        async function callSupabaseFunction(functionName, params) {
            const url = `${SUPABASE_URL}/rest/v1/rpc/${functionName}`;
            const headers = {
                'apikey': SUPABASE_KEY,
                'Authorization': `Bearer ${SUPABASE_KEY}`,
                'Content-Type': 'application/json'
            };
            
            console.log(`🔧 Function Call: ${functionName}`, params);
            
            const response = await fetch(url, {
                method: 'POST',
                headers,
                body: JSON.stringify(params)
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error(`❌ Function Error (${response.status}):`, errorText);
                throw new Error(`Function Error ${response.status}: ${errorText}`);
            }
            
            const data = await response.json();
            console.log(`✅ Function Success:`, data);
            return data;
        }

        // Load custom views on init
        async function loadCustomViews() {
            try {
                const views = await supabaseRequest('actor_classifier_views?is_active=eq.true&order=is_system.desc,name');
                customViews = views;
                displayViewButtons(views);
            } catch (error) {
                console.error('Error loading custom views:', error);
                // Fall back to basic buttons if views can't load
                displayDefaultButtons();
            }
        }

        // Display view buttons dynamically
        function displayViewButtons(views) {
            const container = document.getElementById('filter-buttons');
            container.innerHTML = views.map(view => `
                <button class="search-btn ${view.is_system ? '' : 'custom'}" 
                        onclick="loadActorsWithView('${view.id}', ${JSON.stringify(view.filter_config).replace(/"/g, '&quot;')})">
                    ${view.icon} ${view.name}
                </button>
            `).join('');
            
            // Add create new view button at the end
            container.innerHTML += `
                <button class="search-btn" onclick="openCreateViewModal()">
                    ➕ Create Custom View
                </button>
            `;
        }

        // Display default buttons if views fail to load
        function displayDefaultButtons() {
            const container = document.getElementById('filter-buttons');
            container.innerHTML = `
                <button class="search-btn" onclick="loadActors('review')">
                    📋 Review Unknown Actors
                </button>
                <button class="search-btn" onclick="loadActors('high-priority')">
                    ⭐ High Priority Actors
                </button>
                <button class="search-btn" onclick="loadActors('tpusa')">
                    🏛️ TPUSA Related
                </button>
                <button class="search-btn" onclick="openCreateViewModal()">
                    ➕ Create Custom View
                </button>
            `;
        }

        // Load actors using a custom view
        async function loadActorsWithView(viewId, filterConfig) {
            currentView = { id: viewId, config: filterConfig };
            
            // Update button states
            document.querySelectorAll('.search-btn').forEach(btn => btn.classList.remove('active'));
            // Only update button state if called from a button click
            if (typeof event !== 'undefined' && event && event.target) {
                event.target.classList.add('active');
            }

            // Reset pagination
            currentUnknownActorsPage = 0;
            hasMoreUnknownActors = true;
            currentUnknownActors = [];
            
            // Show results container
            document.getElementById('results-container').style.display = 'block';
            document.getElementById('results-content').innerHTML = '<div class="loading">Loading...</div>';

            try {
                // Build query based on filter config
                const query = buildQueryFromFilter(filterConfig, 0, unknownActorsPageSize);
                const data = await supabaseRequest(query);
                
                // Check if there's more data
                hasMoreUnknownActors = data.length === unknownActorsPageSize;
                
                // Apply frontend filters if needed
                let filteredData = applyFrontendFilters(data, filterConfig);
                
                currentUnknownActors = filteredData;
                displayResults(filteredData, 'custom', null, hasMoreUnknownActors);
                
            } catch (error) {
                console.error('Error loading with view:', error);
                document.getElementById('results-content').innerHTML = 
                    `<div class="error-message">Error loading actors: ${error.message}</div>`;
            }
        }

        // Build query from filter configuration
        function buildQueryFromFilter(config, offset = 0, limit = 50) {
            let query = 'v2_unknown_actors?select=*&review_status=eq.pending';
            
            if (config.filter === 'all') {
                // No additional filters
            } else if (config.filter === 'keyword' && config.keywords) {
                const orClauses = config.keywords.map(kw => 
                    `detected_username=ilike.*${kw}*,profile_bio=ilike.*${kw}*,profile_displayname=ilike.*${kw}*,x_profile_data->>username=ilike.*${kw}*,instagram_profile_data->>username=ilike.*${kw}*,tiktok_profile_data->>username=ilike.*${kw}*,youtube_profile_data->>username=ilike.*${kw}*,truth_social_profile_data->>username=ilike.*${kw}*`
                );
                query += '&or=(' + orClauses.join(',') + ')';
            } else if (config.filter === 'platform' && config.platform) {
                query += `&platform=eq.${config.platform}`;
            } else if (config.filter === 'date_range' && config.days) {
                const date = new Date();
                date.setDate(date.getDate() - config.days);
                query += `&first_seen_date=gte.${date.toISOString()}`;
            } else if (config.filter === 'mention_count' && config.min_mentions) {
                query += `&mention_count=gte.${config.min_mentions}`;
            } else if (config.filter === 'verified' && config.value !== undefined) {
                query += `&verified=eq.${config.value}`;
            } else if (config.filter === 'combined' && config.filters) {
                // Handle combined filters
                config.filters.forEach(f => {
                    if (f.type === 'keyword') {
                        const orClauses = f.keywords.map(kw => 
                            `detected_username=ilike.*${kw}*,profile_bio=ilike.*${kw}*,profile_displayname=ilike.*${kw}*,x_profile_data->>username=ilike.*${kw}*,instagram_profile_data->>username=ilike.*${kw}*,tiktok_profile_data->>username=ilike.*${kw}*,youtube_profile_data->>username=ilike.*${kw}*,truth_social_profile_data->>username=ilike.*${kw}*`
                        );
                        query += '&or=(' + orClauses.join(',') + ')';
                    } else if (f.type === 'platform') {
                        query += `&platform=eq.${f.platform}`;
                    } else if (f.type === 'mention_count') {
                        query += `&mention_count=gte.${f.min_mentions}`;
                    }
                });
            }
            
            query += `&order=mention_count.desc&limit=${limit}&offset=${offset}`;
            return query;
        }

        // Apply frontend filters that can't be done in SQL
        function applyFrontendFilters(data, config) {
            let filtered = data.filter(actor => {
                // Exclude placeholder accounts
                if (actor.x_profile_data && actor.x_profile_data.is_placeholder === true) {
                    return false;
                }
                // Only include actors with profile data
                if (!actor.profile_displayname) {
                    return false;
                }
                return true;
            });
            
            // Apply priority filter
            if (config.filter === 'priority' && config.min_score) {
                filtered = filtered.filter(actor => 
                    (actor.mention_count * 2 + actor.author_count * 5) >= config.min_score
                );
            }
            
            return filtered;
        }

        // Load actors (legacy function for backwards compatibility)
        async function loadActors(searchType, isLoadingMoreParam = false) {
            // Map legacy search types to view configs
            const legacyConfigs = {
                'review': { filter: 'all' },
                'high-priority': { filter: 'priority', min_score: 20 },
                'tpusa': { filter: 'keyword', keywords: ['tpusa', 'turning point'] }
            };
            
            if (legacyConfigs[searchType]) {
                // Find corresponding view
                const view = customViews.find(v => v.name.toLowerCase() === searchType);
                if (view) {
                    loadActorsWithView(view.id, view.filter_config);
                } else {
                    loadActorsWithView('legacy-' + searchType, legacyConfigs[searchType]);
                }
            }
        }

        // Display results in table
        function displayResults(actors, searchType, searchTerm = null, hasMoreData = false) {
            const titles = {
                'custom': currentView ? customViews.find(v => v.id === currentView.id)?.name || 'Custom View' : 'Results',
                'search': searchTerm ? `Search Results for "${searchTerm}"` : 'Search Results'
            };

            document.getElementById('results-title').textContent = (titles[searchType] || 'Results') + ` (${actors.length} found${hasMoreData ? '+' : ''})`;

            if (actors.length === 0) {
                const noResultsMsg = searchType === 'search' && searchTerm ? 
                    `No unknown actors found matching "${searchTerm}". Try different keywords or check spelling.` :
                    'No actors found matching the criteria.';
                document.getElementById('results-content').innerHTML = 
                    `<div class="no-results">${noResultsMsg}</div>`;
                return;
            }

            // Check if this is a network filter result
            const isNetworkView = actors.length > 0 && actors[0].is_network_result;
            
            let tableHTML = `
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Username</th>
                            <th>Profile</th>
                            <th>Display Name</th>
                            <th>Bio Preview</th>
                            <th>Platform</th>
                            <th>Mentions</th>
                            <th>Authors</th>
                            <th>${isNetworkView ? 'Connection Score' : 'Priority'}</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            actors.forEach(actor => {
                const priorityScore = actor.mention_count * 2 + actor.author_count * 5;
                const bioPreview = actor.profile_bio ? 
                    actor.profile_bio.substring(0, 100) + '...' : 'No bio';

                // Build profile URL based on platform
                let profileUrl = '';
                let profileLinkText = 'View';
                if (actor.platform === 'twitter') {
                    profileUrl = `https://twitter.com/${actor.detected_username}`;
                    profileLinkText = '🐦 View';
                } else if (actor.platform === 'instagram') {
                    profileUrl = `https://instagram.com/${actor.detected_username}`;
                    profileLinkText = '📷 View';
                }
                
                tableHTML += `
                    <tr>
                        <td><strong>@${actor.detected_username}</strong></td>
                        <td>
                            ${profileUrl ? `<a href="${profileUrl}" target="_blank" style="color: #007bff; text-decoration: none;">${profileLinkText}</a>` : 'N/A'}
                        </td>
                        <td>${actor.profile_displayname || 'N/A'}</td>
                        <td><div class="bio-preview" title="${actor.profile_bio || ''}">${bioPreview}</div></td>
                        <td>${actor.platform}</td>
                        <td>${actor.mention_count}</td>
                        <td>${actor.author_count}</td>
                        <td>
                            ${
                                actor.is_network_result 
                                ? `<span class="priority-score" style="background: #6f42c1;">${actor.network_interactions || actor.mention_count || 0}</span>`
                                : `<span class="priority-score">${priorityScore}</span>`
                            }
                        </td>
                        <td>
                            ${
                                // Show different buttons based on actor status
                                actor.review_status === 'linked' || actor.review_status === 'network_only' 
                                ? (actor.assigned_actor_id 
                                    ? `<button class="action-btn" onclick="window.location.href='/actor-editor.html?id=${actor.assigned_actor_id}'">View</button>`
                                    : '<span style="color: #666;">Known Actor</span>')
                                : `
                                    <button class="action-btn" onclick="openPromoteModal('${actor.id}')">
                                        Promote
                                    </button>
                                    <button class="action-btn link" onclick="openLinkModal('${actor.id}')">
                                        Link
                                    </button>
                                `
                            }
                        </td>
                    </tr>
                `;
            });

            tableHTML += '</tbody></table>';
            
            // Add Load More button if there's more data
            if (hasMoreData) {
                tableHTML += `
                    <div class="load-more-container" style="text-align: center; margin: 20px 0;">
                        <button class="btn btn-primary" onclick="loadMoreActors()">
                            Load More
                        </button>
                    </div>
                `;
            }
            
            document.getElementById('results-content').innerHTML = tableHTML;
        }

        // Load more actors function
        async function loadMoreActors() {
            if (isLoadingMore || !hasMoreUnknownActors) return;
            
            isLoadingMore = true;
            const loadMoreBtn = document.querySelector('.load-more-container button');
            if (loadMoreBtn) {
                loadMoreBtn.disabled = true;
                loadMoreBtn.textContent = 'Loading...';
            }
            
            try {
                currentUnknownActorsPage++;
                const offset = currentUnknownActorsPage * unknownActorsPageSize;
                
                // Use the current view's filter config
                if (currentView && currentView.config) {
                    const query = buildQueryFromFilter(currentView.config, offset, unknownActorsPageSize);
                    const newData = await supabaseRequest(query);
                    
                    if (newData.length < unknownActorsPageSize) {
                        hasMoreUnknownActors = false;
                    }
                    
                    // Apply frontend filters if needed
                    let filteredData = applyFrontendFilters(newData, currentView.config);
                    
                    // Append to existing data
                    currentUnknownActors = currentUnknownActors.concat(filteredData);
                    
                    // Re-render the entire table with all data
                    displayResults(currentUnknownActors, 'custom', null, hasMoreUnknownActors);
                }
            } catch (error) {
                console.error('Error loading more actors:', error);
                alert('Error loading more actors');
            } finally {
                isLoadingMore = false;
            }
        }

        // Switch between tabs
        function switchTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`${tab}-tab-btn`).classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`${tab}-tab`).classList.add('active');
            
            // Clear searches when switching tabs
            if (tab === 'unknown') {
                // Clear existing actors search
                document.getElementById('existing-actors-main-search').value = '';
            } else {
                // Clear unknown actors search
                document.getElementById('unknown-actors-search').value = '';
                document.getElementById('results-container').style.display = 'none';
                document.querySelectorAll('.search-btn').forEach(btn => btn.classList.remove('active'));
            }
            
            // Load data if needed
            if (tab === 'existing' && existingActors.length === 0) {
                loadExistingActorsMain();
            }
        }

        // Pagination for existing actors
        let existingActorsOffset = 0;
        let existingActorsLimit = 50;
        let hasMoreExistingActors = true;
        let isLoadingExistingActors = false;
        let allExistingActors = [];
        
        // Load existing actors for main tab
        async function loadExistingActorsMain(isLoadMore = false) {
            if (isLoadingExistingActors) return;
            isLoadingExistingActors = true;
            
            try {
                if (!isLoadMore) {
                    existingActorsOffset = 0;
                    allExistingActors = [];
                    document.getElementById('existing-actors-main-list').innerHTML = '<div class="loading">Loading existing actors...</div>';
                }
                
                // Build query with pagination, including primary relationships
                let query = `v2_actors?select=*,primary_relationships:v2_actor_links!actor_links_from_actor_id_fkey(relationship,role,is_primary,to_actor:v2_actors!actor_links_to_actor_id_fkey(id,name,actor_type))&order=name&limit=${existingActorsLimit}&offset=${existingActorsOffset}`;
                
                // Add filter if active
                if (currentActorTypeFilter && currentActorTypeFilter !== 'all') {
                    query = `v2_actors?select=*,primary_relationships:v2_actor_links!actor_links_from_actor_id_fkey(relationship,role,is_primary,to_actor:v2_actors!actor_links_to_actor_id_fkey(id,name,actor_type))&actor_type=eq.${currentActorTypeFilter}&order=name&limit=${existingActorsLimit}&offset=${existingActorsOffset}`;
                }
                
                const actors = await supabaseRequest(query);
                
                // Process actors to extract primary relationships
                actors.forEach(actor => {
                    if (actor.primary_relationships) {
                        actor.primary_relationship = actor.primary_relationships.find(rel => rel.is_primary === true) || actor.primary_relationships[0];
                        delete actor.primary_relationships;
                    }
                });
                
                hasMoreExistingActors = actors.length === existingActorsLimit;
                
                if (isLoadMore) {
                    allExistingActors = allExistingActors.concat(actors);
                    existingActorsOffset += actors.length;
                    // Only display the new actors when loading more
                    displayExistingActorsMain(actors, false);
                } else {
                    allExistingActors = actors;
                    existingActorsOffset += actors.length;
                    // Display all actors and clear content
                    displayExistingActorsMain(allExistingActors, true);
                }
                
            } catch (error) {
                console.error('Error loading existing actors:', error);
                document.getElementById('existing-actors-main-list').innerHTML = 
                    '<div class="error-message">Error loading existing actors</div>';
            } finally {
                isLoadingExistingActors = false;
            }
        }

        // Display existing actors in main tab
        function displayExistingActorsMain(actors, clearContent = true) {
            const container = document.getElementById('existing-actors-main-list');
            
            if (actors.length === 0 && clearContent) {
                container.innerHTML = '<div class="no-results">No actors found</div>';
                return;
            }

            let tableHTML = '';
            
            if (clearContent) {
                tableHTML = `
                    <table class="existing-actors-table" id="main-existing-actors-table">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Name</th>
                                <th>Location</th>
                                <th>Details</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="main-actors-tbody">
                `;
            }

            actors.forEach(actor => {
                const details = getActorDetails(actor);
                
                tableHTML += `
                    <tr>
                        <td>${actor.actor_type}</td>
                        <td><strong>${actor.name}</strong></td>
                        <td>${[actor.city, actor.state].filter(Boolean).join(', ') || 'N/A'}</td>
                        <td>${details}</td>
                        <td>
                            <button class="action-btn add-username" onclick="openInlineEdit('${actor.id}')">
                                Edit
                            </button>
                        </td>
                    </tr>
                `;
            });

            if (clearContent) {
                tableHTML += '</tbody></table>';
                
                // Add Load More button if there are more actors
                if (hasMoreExistingActors) {
                    tableHTML += `
                        <div id="load-more-container" style="text-align: center; margin: 20px 0;">
                            <button class="load-more-btn" onclick="loadMoreExistingActors()" style="padding: 10px 20px; background: #4facfe; color: white; border: none; border-radius: 5px; cursor: pointer;">
                                Load More Actors
                            </button>
                        </div>
                    `;
                }
                
                container.innerHTML = tableHTML;
            } else {
                // Append mode - add new rows to existing table
                const tbody = document.getElementById('main-actors-tbody');
                if (tbody) {
                    tbody.insertAdjacentHTML('beforeend', tableHTML);
                }
                
                // Update load more button visibility
                const loadMoreContainer = document.getElementById('load-more-container');
                if (loadMoreContainer && !hasMoreExistingActors) {
                    loadMoreContainer.remove();
                }
            }
        }

        // Load more existing actors
        async function loadMoreExistingActors() {
            await loadExistingActorsMain(true);
        }
        
        // Get actor details based on type
        function getActorDetails(actor) {
            if (actor.actor_type === 'person') {
                // For people, show their role at primary organization
                if (actor.primary_relationship && actor.primary_relationship.to_actor) {
                    const org = actor.primary_relationship.to_actor.name;
                    const role = actor.primary_relationship.role || actor.primary_relationship.relationship || 'Member';
                    return `${role} at ${org}`;
                }
                return actor.custom_text_1 || 'No role'; // fallback to present_role
            } else if (actor.actor_type === 'organization') {
                return actor.custom_text_1 || 'No type'; // org type
            } else if (actor.actor_type === 'chapter') {
                return actor.custom_text_1 || 'No school type'; // school_type
            }
            return '';
        }

        // Load actor types dynamically from V2 schema
        async function loadActorTypes() {
            try {
                // Load available actor types from the database
                const actorTypes = await supabaseRequest('v2_actor_types?select=*&order=name');
                
                const actorTypeSelector = document.getElementById('actor-type-selector');
                let html = '';
                
                // Add default V2 actor types (these always exist)
                const defaultTypes = [
                    { name: 'person', icon: '👤', description: 'Individual actor' },
                    { name: 'organization', icon: '🏢', description: 'Company or group' },
                    { name: 'chapter', icon: '🏫', description: 'Local chapter' }
                ];
                
                // Add default types
                defaultTypes.forEach(type => {
                    html += `
                        <div class="actor-type-btn" onclick="selectActorType('${type.name}')">
                            <h4>${type.icon} ${type.name.charAt(0).toUpperCase() + type.name.slice(1)}</h4>
                            <p>${type.description}</p>
                        </div>
                    `;
                });
                
                // Add any additional custom actor types from the database
                if (actorTypes && actorTypes.length > 0) {
                    actorTypes.forEach(type => {
                        if (!defaultTypes.some(dt => dt.name === type.name)) {
                            html += `
                                <div class="actor-type-btn" onclick="selectActorType('${type.name}')">
                                    <h4>📋 ${type.name.charAt(0).toUpperCase() + type.name.slice(1)}</h4>
                                    <p>Custom actor type</p>
                                </div>
                            `;
                        }
                    });
                }
                
                actorTypeSelector.innerHTML = html;
                
            } catch (error) {
                console.error('Error loading actor types:', error);
                // Fallback to default types only
                const actorTypeSelector = document.getElementById('actor-type-selector');
                actorTypeSelector.innerHTML = `
                    <div class="actor-type-btn" onclick="selectActorType('person')">
                        <h4>👤 Person</h4>
                        <p>Individual actor</p>
                    </div>
                    <div class="actor-type-btn" onclick="selectActorType('organization')">
                        <h4>🏢 Organization</h4>
                        <p>Company or group</p>
                    </div>
                    <div class="actor-type-btn" onclick="selectActorType('chapter')">
                        <h4>🏫 Chapter</h4>
                        <p>Local chapter</p>
                    </div>
                `;
            }
        }

        // Open promote modal
        async function openPromoteModal(actorId) {
            try {
                const data = await supabaseRequest(`v2_unknown_actors?select=*&id=eq.${actorId}`);

                if (data.length === 0) {
                    throw new Error('Actor not found');
                }

                currentUnknownActor = data[0];
                selectedActorType = null;

                // Load actor types dynamically
                await loadActorTypes();

                // Reset form
                document.getElementById('promote-form').style.display = 'none';
                
                // Load sample posts for this unknown actor
                loadSamplePostsForUnknownActor(actorId);
                
                // Search for similar existing actors
                searchSimilarActorsForUnknownActor(currentUnknownActor);

                document.getElementById('promote-modal').style.display = 'block';

            } catch (error) {
                console.error('Error loading actor:', error);
                alert('Error loading actor details');
            }
        }
        
        // Load sample posts where unknown actor is mentioned
        async function loadSamplePostsForUnknownActor(unknownActorId) {
            try {
                // First, get the post links from v2_post_unknown_actors
                // Note: We do two separate queries because there's no direct foreign key relationship
                // between v2_post_unknown_actors and v2_social_media_posts in Supabase
                const postLinksQuery = `v2_post_unknown_actors?unknown_actor_id=eq.${unknownActorId}&select=post_id,mention_context&limit=3`;
                const postLinks = await supabaseRequest(postLinksQuery);
                
                if (postLinks && postLinks.length > 0) {
                    // Extract post IDs
                    const postIds = postLinks.map(link => link.post_id);
                    
                    // Then fetch the actual posts from v2_social_media_posts
                    const postsQuery = `v2_social_media_posts?id=in.(${postIds.join(',')})&select=id,content_text,author_handle,post_timestamp`;
                    const posts = await supabaseRequest(postsQuery);
                    
                    // Create a map of posts by ID for easy lookup
                    const postsMap = {};
                    posts.forEach(post => {
                        postsMap[post.id] = post;
                    });
                    
                    let samplePostsHTML = '<div style="margin: 15px 0; padding: 10px; background: #f0f7ff; border-radius: 8px;">';
                    samplePostsHTML += '<h4 style="margin-top: 0;">Sample Posts Mentioning This Actor:</h4>';
                    
                    postLinks.forEach(link => {
                        const postData = postsMap[link.post_id];
                        if (postData) {
                            const content = postData.content_text ? postData.content_text.substring(0, 200) + '...' : 'No content';
                            const timestamp = postData.post_timestamp ? new Date(postData.post_timestamp).toLocaleDateString() : '';
                            
                            samplePostsHTML += `
                                <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 4px;">
                                    <small style="color: #666;">${timestamp} • @${postData.author_handle} • ${link.mention_context}</small>
                                    <p style="margin: 5px 0;">${content}</p>
                                </div>
                            `;
                        }
                    });
                    
                    samplePostsHTML += '</div>';
                    
                    // Add sample posts to the modal
                    const promoteContent = document.getElementById('promote-content');
                    const existingSamplePosts = document.getElementById('sample-posts-section');
                    if (existingSamplePosts) {
                        existingSamplePosts.innerHTML = samplePostsHTML;
                    } else {
                        const samplePostsDiv = document.createElement('div');
                        samplePostsDiv.id = 'sample-posts-section';
                        samplePostsDiv.innerHTML = samplePostsHTML;
                        promoteContent.insertBefore(samplePostsDiv, promoteContent.firstChild);
                    }
                } else {
                    // No posts found - show a message
                    const samplePostsHTML = '<div style="margin: 15px 0; padding: 10px; background: #f0f7ff; border-radius: 8px;">' +
                        '<h4 style="margin-top: 0;">Sample Posts Mentioning This Actor:</h4>' +
                        '<p style="color: #666;">No posts found for this unknown actor.</p>' +
                        '</div>';
                    
                    const promoteContent = document.getElementById('promote-content');
                    const existingSamplePosts = document.getElementById('sample-posts-section');
                    if (existingSamplePosts) {
                        existingSamplePosts.innerHTML = samplePostsHTML;
                    } else {
                        const samplePostsDiv = document.createElement('div');
                        samplePostsDiv.id = 'sample-posts-section';
                        samplePostsDiv.innerHTML = samplePostsHTML;
                        promoteContent.insertBefore(samplePostsDiv, promoteContent.firstChild);
                    }
                }
            } catch (error) {
                console.error('Error loading sample posts:', error);
                // Show error message in UI
                const errorHTML = '<div style="margin: 15px 0; padding: 10px; background: #fee; border-radius: 8px;">' +
                    '<h4 style="margin-top: 0; color: #c00;">Error Loading Sample Posts</h4>' +
                    '<p style="color: #666;">Could not load sample posts for this actor.</p>' +
                    '</div>';
                
                const promoteContent = document.getElementById('promote-content');
                const existingSamplePosts = document.getElementById('sample-posts-section');
                if (existingSamplePosts) {
                    existingSamplePosts.innerHTML = errorHTML;
                } else {
                    const samplePostsDiv = document.createElement('div');
                    samplePostsDiv.id = 'sample-posts-section';
                    samplePostsDiv.innerHTML = errorHTML;
                    promoteContent.insertBefore(samplePostsDiv, promoteContent.firstChild);
                }
            }
        }
        
        // Search for similar existing actors
        async function searchSimilarActorsForUnknownActor(unknownActor) {
            try {
                if (!unknownActor.profile_displayname && !unknownActor.detected_username) return;
                
                const searchTerm = unknownActor.profile_displayname || unknownActor.detected_username;
                
                // Search for similar actors by name
                const query = `v2_actors?or=(name=ilike.*${encodeURIComponent(searchTerm)}*,about=ilike.*${encodeURIComponent(searchTerm)}*)&limit=5`;
                const similarActors = await supabaseRequest(query);
                
                if (similarActors && similarActors.length > 0) {
                    let similarActorsHTML = '<div style="margin: 15px 0; padding: 10px; background: #fff9e6; border-radius: 8px;">';
                    similarActorsHTML += '<h4 style="margin-top: 0; color: #856404;">⚠️ Similar Existing Actors Found:</h4>';
                    similarActorsHTML += '<p style="color: #856404; font-size: 14px;">Consider linking to one of these instead of creating a new actor:</p>';
                    
                    similarActors.forEach(actor => {
                        similarActorsHTML += `
                            <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 4px; border: 1px solid #ffc107;">
                                <strong>${actor.name}</strong> (${actor.actor_type})
                                ${actor.city && actor.state ? `<small> • ${actor.city}, ${actor.state}</small>` : ''}
                                <p style="margin: 5px 0; font-size: 14px; color: #666;">${actor.about || 'No description'}</p>
                                <button class="btn btn-warning" style="font-size: 12px;" onclick="switchToLinkModal('${actor.id}', '${actor.name}')">
                                    Link to This Actor Instead
                                </button>
                            </div>
                        `;
                    });
                    
                    similarActorsHTML += '</div>';
                    
                    // Add similar actors to the modal
                    const promoteContent = document.getElementById('promote-content');
                    const existingSimilarActors = document.getElementById('similar-actors-section');
                    if (existingSimilarActors) {
                        existingSimilarActors.innerHTML = similarActorsHTML;
                    } else {
                        const similarActorsDiv = document.createElement('div');
                        similarActorsDiv.id = 'similar-actors-section';
                        similarActorsDiv.innerHTML = similarActorsHTML;
                        // Insert after sample posts if exists, otherwise at the beginning
                        const samplePostsSection = document.getElementById('sample-posts-section');
                        if (samplePostsSection) {
                            promoteContent.insertBefore(similarActorsDiv, samplePostsSection.nextSibling);
                        } else {
                            promoteContent.insertBefore(similarActorsDiv, promoteContent.firstChild);
                        }
                    }
                }
            } catch (error) {
                console.error('Error searching similar actors:', error);
            }
        }
        
        // Switch from promote modal to link modal
        async function switchToLinkModal(actorId, actorName) {
            if (confirm(`Link this unknown actor to "${actorName}"?`)) {
                try {
                    // Use the Supabase RPC function to link unknown actor to existing actor
                    const result = await callSupabaseFunction('link_v2_unknown_to_existing', {
                        p_unknown_actor_id: currentUnknownActor.id,
                        p_existing_actor_id: actorId
                    });
                    
                    alert(`Successfully linked to ${actorName}`);
                    closeModal('promote-modal');
                    
                    // Reload the current view
                    if (networkFilterActive) {
                        // Reapply network filter
                        applyNetworkFilter();
                    } else if (currentView && currentView.id) {
                        loadActorsWithView(currentView.id, currentView.config || currentView.filter_config);
                    } else {
                        // Fallback to reload all unknown actors
                        loadActorsWithView('all', { filter: 'all' });
                    }
                    
                } catch (error) {
                    console.error('Error linking actor:', error);
                    alert('Error linking actor: ' + (error.message || 'Unknown error'));
                }
            }
        }

        // Select actor type for promotion
        function selectActorType(type) {
            console.log('selectActorType called with:', type);
            selectedActorType = type;
            
            // Update button states
            document.querySelectorAll('#promote-content .actor-type-btn').forEach(btn => btn.classList.remove('selected'));
            if (event && event.target) {
                event.target.closest('.actor-type-btn').classList.add('selected');
            }

            // Generate form
            generatePromoteForm(type);
            
            // Show the form
            document.getElementById('promote-form').style.display = 'block';
        }

        // Get actor type ID for field mappings
        async function getActorTypeId(actorType) {
            try {
                const result = await supabaseRequest(`v2_actor_types?select=id&name=eq.${actorType}`);
                if (result && result.length > 0) {
                    return result[0].id;
                }
                return null;
            } catch (error) {
                console.error('Error getting actor type ID:', error);
                return null;
            }
        }

        // Get field mappings for actor type
        async function getFieldMappings(actorTypeId) {
            try {
                const result = await supabaseRequest(`v2_actor_type_field_mappings?select=*&actor_type_id=eq.${actorTypeId}&order=field_name`);
                return result || [];
            } catch (error) {
                console.error('Error getting field mappings:', error);
                return [];
            }
        }

        // Get existing values for autocomplete
        async function getExistingValues(fieldName, columnName, isIndexed) {
            try {
                let query;
                if (isIndexed) {
                    // For indexed fields, query the actual column
                    query = `v2_actors?select=${columnName}&${columnName}=not.is.null&order=${columnName}&limit=50`;
                } else {
                    // For metadata fields, this is more complex - we'll handle basic cases
                    // For now, return empty array for metadata fields
                    return [];
                }
                
                const result = await supabaseRequest(query);
                if (result && result.length > 0) {
                    // Get unique values
                    const values = result.map(row => row[columnName]).filter(val => val && val.trim());
                    return [...new Set(values)].sort();
                }
                return [];
            } catch (error) {
                console.error('Error getting existing values:', error);
                return [];
            }
        }

        // Generate form field HTML based on field mapping
        function generateFieldHTML(field, existingValues = [], defaultValue = '') {
            const fieldId = field.field_name.toLowerCase().replace(/\s+/g, '_');
            let html = '';

            if (field.data_type === 'boolean') {
                html = `
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="${fieldId}" ${defaultValue === 'true' ? 'checked' : ''}>
                            ${field.field_name}
                        </label>
                    </div>
                `;
            } else if (field.data_type === 'text' && field.field_name.toLowerCase().includes('about')) {
                html = `
                    <div class="form-group">
                        <label>${field.field_name}</label>
                        <textarea id="${fieldId}">${defaultValue}</textarea>
                    </div>
                `;
            } else if (existingValues.length > 0) {
                // Create input with datalist for autocomplete
                const listId = `${fieldId}_list`;
                html = `
                    <div class="form-group">
                        <label>${field.field_name}</label>
                        <input type="text" id="${fieldId}" list="${listId}" value="${defaultValue}" placeholder="Type or select existing...">
                        <datalist id="${listId}">
                            ${existingValues.map(value => `<option value="${value}">`).join('')}
                        </datalist>
                    </div>
                `;
            } else {
                // Regular input field
                const inputType = field.data_type === 'date' ? 'date' : 
                                 field.data_type === 'numeric' ? 'number' : 'text';
                html = `
                    <div class="form-group">
                        <label>${field.field_name}</label>
                        <input type="${inputType}" id="${fieldId}" value="${defaultValue}">
                    </div>
                `;
            }

            return html;
        }

        // Enhanced actor linking section with all available columns
        async function generateActorLinkingSection(actorType) {
            // Get existing relationship types and roles for autocomplete
            let relationshipTypes = [];
            let roles = [];
            let roleCategories = [];
            
            try {
                // Get existing relationship types
                const relationshipResult = await supabaseRequest('v2_actor_links?select=relationship&relationship=not.is.null&order=relationship&limit=50');
                if (relationshipResult) {
                    relationshipTypes = [...new Set(relationshipResult.map(r => r.relationship).filter(r => r))].sort();
                }

                // Get existing roles
                const roleResult = await supabaseRequest('v2_actor_links?select=role&role=not.is.null&order=role&limit=50');
                if (roleResult) {
                    roles = [...new Set(roleResult.map(r => r.role).filter(r => r))].sort();
                }

                // Get existing role categories
                const roleCategoryResult = await supabaseRequest('v2_actor_links?select=role_category&role_category=not.is.null&order=role_category&limit=50');
                if (roleCategoryResult) {
                    roleCategories = [...new Set(roleCategoryResult.map(r => r.role_category).filter(r => r))].sort();
                }
            } catch (error) {
                console.error('Error loading relationship autocomplete data:', error);
            }

            return `
                <div class="actor-link-section">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enable-actor-links" onchange="toggleActorLinking()">
                        <strong>Link this ${actorType} to other actors</strong>
                    </label>
                    
                    <div id="actor-linking-section" style="display: none; margin-top: 15px;">
                        <div class="form-group">
                            <label>Search for actors to link</label>
                            <input type="text" id="promote-link-search" placeholder="Search actors..." onkeyup="debouncedSearchPromoteLinks()">
                        </div>
                        <div id="promote-link-results" style="max-height: 150px; overflow-y: auto; margin: 10px 0;"></div>
                        <div id="promote-linked-actors" class="linked-actors-list">
                            <!-- Selected actors will appear here -->
                        </div>
                        
                        <!-- Enhanced relationship form with autocomplete -->
                        <div id="relationship-form" style="display: none; margin-top: 15px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background: #f9f9f9;">
                            <h4>Link Details</h4>
                            <div class="form-grid-2">
                                <div class="form-group">
                                    <label>Relationship Type</label>
                                    <input type="text" id="link-relationship" list="relationship-types" placeholder="e.g., member_of, works_for, leads">
                                    <datalist id="relationship-types">
                                        ${relationshipTypes.map(type => `<option value="${type}">`).join('')}
                                    </datalist>
                                </div>
                                <div class="form-group">
                                    <label>Role</label>
                                    <input type="text" id="link-role" list="roles" placeholder="e.g., President, Member, Director">
                                    <datalist id="roles">
                                        ${roles.map(role => `<option value="${role}">`).join('')}
                                    </datalist>
                                </div>
                            </div>
                            <div class="form-grid-2">
                                <div class="form-group">
                                    <label>Role Category</label>
                                    <input type="text" id="link-role-category" list="role-categories" placeholder="e.g., leadership, staff, volunteer">
                                    <datalist id="role-categories">
                                        ${roleCategories.map(cat => `<option value="${cat}">`).join('')}
                                    </datalist>
                                </div>
                                <div class="form-group">
                                    <label class="checkbox-label">
                                        <input type="checkbox" id="link-is-primary">
                                        Primary relationship
                                    </label>
                                </div>
                            </div>
                            <div class="form-grid-2">
                                <div class="form-group">
                                    <label>Start Date (Optional)</label>
                                    <input type="date" id="link-start-date">
                                </div>
                                <div class="form-group">
                                    <label>End Date (Optional)</label>
                                    <input type="date" id="link-end-date">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Generate promotion form based on actor type
        async function generatePromoteForm(type) {
            selectedActorType = type;
            
            console.log('Generating promote form for type:', type);
            console.log('Current unknown actor:', currentUnknownActor);
            
            // For now, always use the basic form that we know works
            return generateBasicPromoteForm(type);
            
            /* Temporarily disabled dynamic form generation
            try {
                // Get actor type ID and field mappings
                const actorTypeId = await getActorTypeId(type);
                if (!actorTypeId) {
                    console.warn(`Actor type '${type}' not found, falling back to basic form`);
                    return generateBasicPromoteForm(type);
                }

                const fieldMappings = await getFieldMappings(actorTypeId);
                console.log(`Found ${fieldMappings.length} field mappings for ${type}`);

                let formHTML = '<div id="success-message" style="display: none;"></div>';

                // Generate fields based on mappings
                for (const field of fieldMappings) {
                    // Get existing values for autocomplete (only for indexed text fields)
                    let existingValues = [];
                    if (field.is_indexed && field.data_type === 'text') {
                        existingValues = await getExistingValues(field.field_name, field.column_name, field.is_indexed);
                    }

                    // Determine default value from profile data
                    let defaultValue = '';
                    if (field.field_name.toLowerCase().includes('name')) {
                        defaultValue = actor.profile_displayname || '';
                    } else if (field.field_name.toLowerCase().includes('about') || field.field_name.toLowerCase().includes('bio')) {
                        defaultValue = actor.profile_bio || '';
                    } else if (field.field_name.toLowerCase().includes('city')) {
                        defaultValue = profileLocation;
                    }

                    formHTML += generateFieldHTML(field, existingValues, defaultValue);
                }

                // Add special handling for organizations dropdown if this is a person
                if (type === 'person') {
                    if (organizations.length === 0) {
                        await loadOrganizations();
                    }
                    
                    formHTML += `
                        <div class="form-group">
                            <label>Primary Organization (Optional)</label>
                            <select id="primary_organization_id">
                                <option value="">Select organization...</option>
                                ${organizations.map(org => 
                                    `<option value="${org.id}">${org.name}</option>`
                                ).join('')}
                            </select>
                        </div>
                    `;
                }

                // Add actor linking section
                formHTML += await generateActorLinkingSection(type);

                // Add form actions
                formHTML += `
                    <div class="form-actions">
                        <button class="btn btn-secondary" onclick="closeModal('promote-modal')">Cancel</button>
                        <button class="btn btn-primary" onclick="promoteActor()">
                            Create ${type.charAt(0).toUpperCase() + type.slice(1)}
                        </button>
                    </div>
                `;

                document.getElementById('promote-form').innerHTML = formHTML;
                document.getElementById('promote-form').style.display = 'block';

            } catch (error) {
                console.error('Error generating dynamic form:', error);
                // Fallback to basic form
                generateBasicPromoteForm(type);
            }
            */
        }

        // Fallback basic form generator (original hardcoded logic)
        async function generateBasicPromoteForm(type) {
            const actor = currentUnknownActor;
            
            // Extract location for pre-population
            const profileLocation = actor.profile_location || '';
            
            // Load organizations for forms that need them
            if (type === 'person' && organizations.length === 0) {
                await loadOrganizations();
            }
            
            if (type === 'person' && existingRoleCategories.length === 0) {
                await loadExistingRoleCategories();
            }

            let formHTML = '<div id="success-message" style="display: none;"></div>';

            if (type === 'person') {
                formHTML += `
                    <div class="form-group">
                        <label>Full Name</label>
                        <input type="text" id="full_name" value="${currentUnknownActor.profile_displayname || ''}">
                    </div>
                    <div class="form-group">
                        <label>Present Role</label>
                        <input type="text" id="present_role" value="">
                    </div>
                    <div class="form-group">
                        <label>Role Category</label>
                        <input type="text" id="role_category" list="role_categories" placeholder="Type or select existing category...">
                        <datalist id="role_categories">
                            ${existingRoleCategories.map(category => 
                                `<option value="${category}">`
                            ).join('')}
                        </datalist>
                    </div>
                    <div class="form-grid-2">
                        <div class="form-group">
                            <label>City</label>
                            <input type="text" id="promote-city" value="${profileLocation}">
                        </div>
                        <div class="form-group">
                            <label>State</label>
                            <input type="text" id="promote-state" placeholder="e.g., Arizona, California" value="">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>About</label>
                        <textarea id="promote-about">${currentUnknownActor.profile_bio || ''}</textarea>
                    </div>
                    <div class="form-grid-2">
                        <div class="form-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="is_tpusa_staff">
                                TPUSA Staff
                            </label>
                        </div>
                        <div class="form-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="is_tpusa_affiliated">
                                TPUSA Affiliated
                            </label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Primary Organization (Optional)</label>
                        <select id="primary_organization_id">
                            <option value="">Select organization...</option>
                            ${organizations.map(org => 
                                `<option value="${org.id}">${org.name}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
                
                // Add actor linking section for person
                formHTML += `
                    <div class="actor-link-section">
                        <label class="checkbox-label">
                            <input type="checkbox" id="enable-actor-links" onchange="toggleActorLinking()">
                            <strong>Link this person to other actors</strong>
                        </label>
                        
                        <div id="actor-linking-section" style="display: none; margin-top: 15px;">
                            <div class="form-group">
                                <label>Search for actors to link</label>
                                <input type="text" id="promote-link-search" placeholder="Search actors..." onkeyup="debouncedSearchPromoteLinks()">
                            </div>
                            <div id="promote-link-results" style="max-height: 150px; overflow-y: auto; margin: 10px 0;"></div>
                            <div id="promote-linked-actors" class="linked-actors-list">
                                <!-- Selected actors will appear here -->
                            </div>
                        </div>
                    </div>
                `;
            } else if (type === 'organization') {
                formHTML += `
                    <div class="form-group">
                        <label>Organization Name</label>
                        <input type="text" id="promote-org-name" value="${currentUnknownActor.profile_displayname || ''}">
                    </div>
                    <div class="form-group">
                        <label>Type</label>
                        <select id="type">
                            <option value="external">External</option>
                            <option value="tpusa">TPUSA</option>
                            <option value="affiliate">Affiliate</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Summary/Focus</label>
                        <textarea id="summary_focus">${currentUnknownActor.profile_bio || ''}</textarea>
                    </div>
                    <div class="form-group">
                        <label>Region Scope</label>
                        <input type="text" id="region_scope" placeholder="e.g., Local, Regional, National">
                    </div>
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="is_tpusa">
                            Is TPUSA Organization
                        </label>
                    </div>
                `;
                
                // Add actor linking section for organization
                formHTML += `
                    <div class="actor-link-section">
                        <label class="checkbox-label">
                            <input type="checkbox" id="enable-actor-links" onchange="toggleActorLinking()">
                            <strong>Link this organization to other actors</strong>
                        </label>
                        
                        <div id="actor-linking-section" style="display: none; margin-top: 15px;">
                            <div class="form-group">
                                <label>Search for actors to link</label>
                                <input type="text" id="promote-link-search" placeholder="Search actors..." onkeyup="debouncedSearchPromoteLinks()">
                            </div>
                            <div id="promote-link-results" style="max-height: 150px; overflow-y: auto; margin: 10px 0;"></div>
                            <div id="promote-linked-actors" class="linked-actors-list">
                                <!-- Selected actors will appear here -->
                            </div>
                        </div>
                    </div>
                `;
            } else if (type === 'chapter') {
                formHTML += `
                    <div class="form-group">
                        <label>Chapter Name</label>
                        <input type="text" id="promote-chapter-name" value="${currentUnknownActor.profile_displayname || ''}">
                    </div>
                    <div class="form-group">
                        <label>School Type</label>
                        <select id="school_type">
                            <option value="college">College</option>
                            <option value="high_school">High School</option>
                        </select>
                    </div>
                    <div class="form-grid-2">
                        <div class="form-group">
                            <label>City</label>
                            <input type="text" id="promote-city" value="${profileLocation}">
                        </div>
                        <div class="form-group">
                            <label>State Code</label>
                            <input type="text" id="state_code" placeholder="e.g., AZ, CA, TX" maxlength="2">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="active" checked>
                            Active Chapter
                        </label>
                    </div>
                `;
                
                // Add actor linking section for chapter
                formHTML += `
                    <div class="actor-link-section">
                        <label class="checkbox-label">
                            <input type="checkbox" id="enable-actor-links" onchange="toggleActorLinking()">
                            <strong>Link this chapter to other actors</strong>
                        </label>
                        
                        <div id="actor-linking-section" style="display: none; margin-top: 15px;">
                            <div class="form-group">
                                <label>Search for actors to link</label>
                                <input type="text" id="promote-link-search" placeholder="Search actors..." onkeyup="debouncedSearchPromoteLinks()">
                            </div>
                            <div id="promote-link-results" style="max-height: 150px; overflow-y: auto; margin: 10px 0;"></div>
                            <div id="promote-linked-actors" class="linked-actors-list">
                                <!-- Selected actors will appear here -->
                            </div>
                        </div>
                    </div>
                `;
            }

            formHTML += `
                <div class="form-actions">
                    <button class="btn btn-secondary" onclick="closeModal('promote-modal')">Cancel</button>
                    <button class="btn btn-primary" onclick="promoteActor()">
                        Create ${type.charAt(0).toUpperCase() + type.slice(1)}
                    </button>
                </div>
            `;

            document.getElementById('promote-form').innerHTML = formHTML;
            document.getElementById('promote-form').style.display = 'block';
        }

        // Load organizations
        async function loadOrganizations() {
            try {
                const data = await supabaseRequest('v2_actors?select=id,name&actor_type=eq.organization&order=name');
                organizations = data;
            } catch (error) {
                console.error('Error loading organizations:', error);
            }
        }

        // Load existing role categories
        async function loadExistingRoleCategories() {
            try {
                const data = await supabaseRequest('v2_actors?select=custom_text_2&actor_type=eq.person&custom_text_2=not.is.null&custom_text_2=neq.&order=custom_text_2');
                // Get unique role categories
                const uniqueCategories = [...new Set(data.map(p => p.custom_text_2).filter(Boolean))];
                existingRoleCategories = uniqueCategories;
            } catch (error) {
                console.error('Error loading role categories:', error);
            }
        }

        // Promote actor using V2 function
        async function promoteActor() {
            const actor = currentUnknownActor;
            const type = selectedActorType;

            try {
                // Build fields object based on actor type
                    let fields = {};
                    let name, city, state;
                    
                    if (type === 'person') {
                        name = document.getElementById('full_name').value || currentUnknownActor.profile_displayname;
                        city = document.getElementById('promote-city').value || null;
                        state = document.getElementById('promote-state').value || null;
                        
                        fields = {
                            present_role: document.getElementById('present_role').value || null,
                            role_category: document.getElementById('role_category').value || null,
                            primary_organization_id: document.getElementById('primary_organization_id').value || null,
                            about: document.getElementById('promote-about').value || null,
                            is_tpusa_staff: document.getElementById('is_tpusa_staff').checked,
                            is_tpusa_affiliated: document.getElementById('is_tpusa_affiliated').checked
                        };
                    } else if (type === 'organization') {
                        name = document.getElementById('promote-org-name').value || currentUnknownActor.profile_displayname;
                        
                        fields = {
                            type: document.getElementById('type').value,
                            summary_focus: document.getElementById('summary_focus').value || null,
                            region_scope: document.getElementById('region_scope').value || null,
                            is_tpusa: document.getElementById('is_tpusa').checked
                        };
                    } else if (type === 'chapter') {
                        name = document.getElementById('promote-chapter-name').value || currentUnknownActor.profile_displayname;
                        city = document.getElementById('promote-city').value || null;
                        state = document.getElementById('state_code').value || null;
                        
                        fields = {
                            school_type: document.getElementById('school_type').value,
                            state_code: state,
                            active: document.getElementById('active').checked
                        };
                    }
                    
                    // Call V2 promotion function
                    const result = await callSupabaseFunction('promote_v2_unknown_to_actor', {
                        p_unknown_actor_id: currentUnknownActor.id,
                        p_actor_type: type,
                        p_name: name,
                        p_city: city,
                        p_state: state,
                        p_fields: fields
                    });
                    
                    const newActorId = result;
                    
                    // Add actor links if any were selected (using v2_actor_links)
                    if (selectedLinkedActors.length > 0) {
                        for (let i = 0; i < selectedLinkedActors.length; i++) {
                            const linkedActor = selectedLinkedActors[i];
                            const relType = document.getElementById(`promote-rel-${i}`).value;
                            
                            if (!relType) {
                                console.warn(`Skipping link to ${linkedActor.name} - no relationship type selected`);
                                continue;
                            }
                            
                            // Collect metadata fields
                            const metadata = {};
                            const metadataDiv = document.getElementById(`promote-metadata-${i}`);
                            const metadataFields = metadataDiv.querySelectorAll('.metadata-field');
                            
                            metadataFields.forEach((field, j) => {
                                const key = field.querySelector(`#promote-meta-key-${i}-${j}`).value;
                                const value = field.querySelector(`#promote-meta-value-${i}-${j}`).value;
                                if (key && value) {
                                    metadata[key] = value;
                                }
                            });
                            
                            try {
                                await supabaseRequest('v2_actor_links', {
                                    method: 'POST',
                                    body: JSON.stringify({
                                        from_actor_id: newActorId,
                                        to_actor_id: linkedActor.id,
                                        relationship: relType,
                                        role: document.getElementById(`promote-role-${i}`).value || null,
                                        role_category: document.getElementById(`promote-role-cat-${i}`).value || null,
                                        is_primary: document.getElementById(`promote-primary-${i}`).checked,
                                        start_date: document.getElementById(`promote-start-${i}`).value || null,
                                        end_date: document.getElementById(`promote-end-${i}`).value || null,
                                        metadata: Object.keys(metadata).length > 0 ? metadata : {},
                                        created_at: new Date().toISOString()
                                    })
                                });
                            } catch (linkError) {
                                console.error('Error creating actor link:', linkError);
                            }
                        }
                    }
                    
                    showSuccessMessage('Successfully promoted actor! All links have been migrated automatically.');
                } catch (error) {
                    console.error('Error promoting actor:', error);
                    showErrorMessage('Failed to promote actor: ' + error.message);
                }
                
                // Clear selected linked actors
                selectedLinkedActors = [];
                
                // Refresh results
                setTimeout(() => {
                    closeModal('promote-modal');
                    if (networkFilterActive) {
                        // Reapply network filter
                        applyNetworkFilter();
                    } else if (currentView) {
                        loadActorsWithView(currentView.id, currentView.config);
                    }
                }, 2000);
        }

        // Open link to existing modal
        async function openLinkModal(actorId) {
            try {
                if (!actorId) {
                    throw new Error('No actor ID provided');
                }

                console.log('Opening link modal for actor:', actorId);
                const data = await supabaseRequest(`v2_unknown_actors?select=*&id=eq.${actorId}`);

                if (!data || data.length === 0) {
                    throw new Error('Actor not found in database');
                }

                currentUnknownActor = data[0];
                console.log('Loaded unknown actor:', currentUnknownActor);
                
                selectedExistingActor = null;
                
                // Display unknown actor info
                const infoDiv = document.getElementById('unknown-actor-info');
                if (infoDiv) {
                    const profileData = currentUnknownActor[`${currentUnknownActor.platform}_profile_data`] || {};
                    const followerCount = currentUnknownActor.follower_count || profileData.follower_count || 'N/A';
                    
                    infoDiv.innerHTML = `
                        <h3 style="margin-top: 0; color: #333;">Linking Unknown Actor:</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div><strong>Username:</strong> @${currentUnknownActor.detected_username}</div>
                            <div><strong>Platform:</strong> ${currentUnknownActor.platform}</div>
                            <div><strong>Display Name:</strong> ${currentUnknownActor.profile_displayname || 'N/A'}</div>
                            <div><strong>Followers:</strong> ${followerCount.toLocaleString()}</div>
                            <div style="grid-column: 1 / -1;"><strong>Bio:</strong> ${currentUnknownActor.profile_bio || 'No bio available'}</div>
                            <div style="grid-column: 1 / -1;"><strong>Location:</strong> ${currentUnknownActor.profile_location || 'Not specified'}</div>
                            <div style="grid-column: 1 / -1;"><strong>Mentions:</strong> ${currentUnknownActor.mention_count || 0} | <strong>Posts:</strong> ${currentUnknownActor.author_count || 0}</div>
                        </div>
                    `;
                }
                
                // Reset actor type filter to 'all'
                currentActorTypeFilter = 'all';
                const linkContent = document.getElementById('link-content');
                if (linkContent) {
                    const typeButtons = linkContent.querySelectorAll('.actor-type-btn');
                    typeButtons.forEach(btn => {
                        btn.classList.remove('selected');
                        if (btn.dataset.type === 'all') {
                            btn.classList.add('selected');
                        }
                    });
                } else {
                    console.warn('link-content element not found');
                }
                
                // Reset selected actor and disable link button
                selectedExistingActor = null;
                const linkButton = document.getElementById('link-actor-button');
                if (linkButton) {
                    linkButton.disabled = true;
                }
                
                // Clear search input
                const searchInput = document.getElementById('actor-search-input');
                if (searchInput) {
                    searchInput.value = '';
                }
                
                // Hide actor preview
                hideActorPreview();

                // Load existing actors
                await loadExistingActors();
                
                // Search for similar actors and add suggestions
                await addLinkSuggestions();

                const linkModal = document.getElementById('link-modal');
                if (linkModal) {
                    linkModal.style.display = 'block';
                } else {
                    console.error('link-modal element not found');
                    throw new Error('Link modal element not found in DOM');
                }

            } catch (error) {
                console.error('Error loading actor:', error);
                const errorMessage = error?.message || error?.toString() || 'Unknown error occurred';
                alert('Error loading actor details: ' + errorMessage);
            }
        }
        
        // Add suggestions for linking based on similar names
        async function addLinkSuggestions() {
            if (!currentUnknownActor) return;
            
            try {
                // Search for similar actors using the unknown actor's name
                const searchName = currentUnknownActor.detected_username || currentUnknownActor.profile_name || '';
                if (!searchName) return;
                
                // Use the SQL function to search for similar actors
                const similarActors = await callSupabaseFunction('search_similar_v2_actors', {
                    p_search_term: searchName,
                    p_bio_text: currentUnknownActor.profile_bio,
                    p_limit: 5
                });
                
                if (similarActors && similarActors.length > 0) {
                    // Show suggestions in dedicated section
                    const suggestionsDiv = document.getElementById('link-suggestions');
                    if (suggestionsDiv) {
                        let suggestionsHTML = `
                            <div style="background: #f0f7ff; padding: 15px; border-radius: 8px; border: 2px solid #4facfe;">
                                <h4 style="margin: 0 0 10px 0; color: #333;">🔍 Suggested Matches</h4>
                                <div style="display: grid; gap: 10px;">
                        `;
                        
                        similarActors.forEach(actor => {
                            const similarity = Math.max(actor.name_similarity || 0, actor.bio_similarity || 0);
                            const percentage = Math.round(similarity * 100);
                            const location = [actor.city, actor.state].filter(Boolean).join(', ');
                            
                            // Cache the actor data
                            linkModalActorCache[actor.id] = actor;
                            
                            suggestionsHTML += `
                                <div style="background: white; padding: 10px; border-radius: 6px; border: 1px solid #dee2e6;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;"
                                         onclick="selectLinkActor('${actor.id}')"
                                         onmouseover="this.style.background='#e3f2fd';"
                                         onmouseout="this.style.background='transparent';">
                                        <div style="flex: 1;">
                                            <strong style="color: #333;">${actor.name}</strong>
                                            <span style="color: #666; font-size: 12px;">(${actor.actor_type})</span>
                                            ${location ? `<span style="color: #999; font-size: 12px; margin-left: 10px;">${location}</span>` : ''}
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <button class="btn btn-sm" onclick="event.stopPropagation(); toggleSuggestionDetails('${actor.id}')" 
                                                    style="padding: 2px 8px; font-size: 11px; background: #4facfe; color: white; border: none; border-radius: 3px;">
                                                <span id="suggest-toggle-btn-${actor.id}">▼ More</span>
                                            </button>
                                            <div style="background: ${percentage > 70 ? '#4caf50' : percentage > 40 ? '#ff9800' : '#f44336'}; 
                                                        color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold;">
                                                ${percentage}%
                                            </div>
                                        </div>
                                    </div>
                                    <div id="suggest-details-${actor.id}" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #dee2e6;">
                                        <div id="suggest-details-content-${actor.id}" style="max-height: 300px; overflow-y: auto;">
                                            <!-- Details will be loaded when expanded -->
                                        </div>
                                    </div>
                                </div>
                            `;
                        });
                        
                        suggestionsHTML += `
                                </div>
                            </div>
                        `;
                        
                        suggestionsDiv.innerHTML = suggestionsHTML;
                        suggestionsDiv.style.display = 'block';
                        
                        // Clear previous suggestions from the actors lists first
                        // Remove any actors that were marked as suggestions
                        if (window.previousSuggestionIds) {
                            existingActors = existingActors.filter(a => !window.previousSuggestionIds.has(a.id));
                            filteredExistingActors = filteredExistingActors.filter(a => !window.previousSuggestionIds.has(a.id));
                        }
                        
                        // Track current suggestions for next time
                        window.previousSuggestionIds = new Set(similarActors.map(a => a.id));
                        
                        // Also put suggestions at top of both lists
                        // Merge suggestions with existing actors, avoiding duplicates
                        const uniqueSuggestions = similarActors.filter(s => !existingActors.find(e => e.id === s.id));
                        existingActors = [...uniqueSuggestions, ...existingActors];
                        filteredExistingActors = [...similarActors, ...existingActors.filter(a => !similarActors.find(s => s.id === a.id))];
                        displayLinkActors(filteredExistingActors);
                    }
                }
                
            } catch (error) {
                console.error('Error searching for similar actors:', error);
                // Continue without suggestions if search fails
            }
        }

        // Load existing actors for linking
        async function loadExistingActors(isLoadMore = false) {
            if (isLoadingLinkSearch && isLoadMore) return;
            
            try {
                const tbody = document.getElementById('link-actors-tbody');
                if (!tbody) {
                    console.error('link-actors-tbody element not found');
                    return;
                }
                
                if (!isLoadMore) {
                    linkSearchOffset = 0;
                    existingActors = [];
                    filteredExistingActors = [];
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 20px;">Loading actors...</td></tr>';
                }
                
                isLoadingLinkSearch = true;

                // Load from v2_actors with pagination
                const actors = await supabaseRequest(`v2_actors?select=*&order=name&limit=${linkSearchLimit}&offset=${linkSearchOffset}`);
                
                hasMoreLinkResults = actors.length === linkSearchLimit;
                linkSearchOffset += actors.length;
                
                if (isLoadMore) {
                    existingActors = [...existingActors, ...actors];
                    filteredExistingActors = [...filteredExistingActors, ...actors];
                    // Display only the new actors in append mode
                    displayLinkActors(actors, true);
                } else {
                    existingActors = actors;
                    filteredExistingActors = actors;
                    // Display all actors, replacing content
                    displayLinkActors(filteredExistingActors, false);
                }
                
                // Also load and show suggestions on initial load
                if (!isLoadMore) {
                    await addLinkSuggestions();
                }

            } catch (error) {
                console.error('Error loading existing actors:', error);
                const tbody = document.getElementById('link-actors-tbody');
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: red;">Error loading actors</td></tr>';
                }
            } finally {
                isLoadingLinkSearch = false;
            }
        }
        
        // Display actors in the link modal table
        function displayLinkActors(actors, append = false) {
            const tbody = document.getElementById('link-actors-tbody');
            if (!tbody) return;
            
            if (!append && (!actors || actors.length === 0)) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center;">No actors found</td></tr>';
                return;
            }
            
            let html = '';
            
            // If appending, remove the load more button first
            if (append) {
                const loadMoreRow = tbody.querySelector('tr:last-child button.action-btn');
                if (loadMoreRow) {
                    loadMoreRow.closest('tr').remove();
                }
            }
            
            actors.forEach(actor => {
                const location = [actor.city, actor.state].filter(Boolean).join(', ') || 'N/A';
                const details = actor.about ? actor.about.substring(0, 100) + '...' : 'No description';
                
                html += `
                    <tr onclick="selectLinkActor('${actor.id}')" style="cursor: pointer;" data-actor-id="${actor.id}">
                        <td><span class="actor-type-badge ${actor.actor_type}">${actor.actor_type}</span></td>
                        <td>
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <strong>${actor.name}</strong>
                                <button class="btn btn-sm" onclick="event.stopPropagation(); toggleActorDetails('${actor.id}')" 
                                        style="margin-left: 10px; padding: 2px 8px; font-size: 11px; background: #4facfe; color: white; border: none; border-radius: 3px; white-space: nowrap;">
                                    <span id="toggle-btn-${actor.id}">▼ More</span>
                                </button>
                            </div>
                        </td>
                        <td>${location}</td>
                        <td style="font-size: 12px; color: #666;">${details}</td>
                    </tr>
                    <tr id="details-${actor.id}" style="display: none; background: #e8f4ff;">
                        <td colspan="4" style="padding: 15px; border: 2px solid #4facfe;">
                            <div id="actor-details-content-${actor.id}" style="max-height: 400px; overflow-y: auto; min-height: 50px;">
                                <!-- Details will be loaded when expanded -->
                            </div>
                        </td>
                    </tr>
                `;
            });
            
            // Add load more button if there are more results
            console.log('Checking if should show Load More button. hasMoreLinkResults:', hasMoreLinkResults);
            if (hasMoreLinkResults) {
                console.log('Adding Load More button to HTML');
                html += `
                    <tr id="load-more-row">
                        <td colspan="4" style="text-align: center; padding: 10px;">
                            <button class="action-btn" onclick="loadMoreLinkActors()" style="width: 200px;">
                                Load More Actors
                            </button>
                        </td>
                    </tr>
                `;
            }
            
            if (append) {
                // Append new rows
                const tempDiv = document.createElement('tbody');
                tempDiv.innerHTML = html;
                while (tempDiv.firstChild) {
                    tbody.appendChild(tempDiv.firstChild);
                }
            } else {
                tbody.innerHTML = html;
            }
        }
        
        // Load more actors in link modal
        async function loadMoreLinkActors() {
            console.log('loadMoreLinkActors called');
            console.log('currentAdvancedSearchCriteria:', currentAdvancedSearchCriteria);
            console.log('hasMoreLinkResults:', hasMoreLinkResults);
            
            // Check if we're in advanced search mode
            if (currentAdvancedSearchCriteria) {
                console.log('Loading more advanced search results...');
                // Load more advanced search results
                await performAdvancedActorSearch(true);
            } else {
                // Check for either search input ID
                const searchInput = document.getElementById('existing-actor-search') || document.getElementById('actor-search-input');
                const searchTerm = searchInput ? searchInput.value.trim() : '';
                console.log('Search term:', searchTerm);
                
                if (searchTerm && searchTerm.length >= 2) {
                    console.log('Loading more search results...');
                    await searchExistingActors(true);
                } else {
                    console.log('Loading more regular results...');
                    await loadExistingActors(true);
                }
            }
        }
        
        // Filter actors by type in link modal
        function filterLinkActorType(type) {
            currentActorTypeFilter = type;
            
            // Update button states
            document.querySelectorAll('#link-content .actor-type-btn').forEach(btn => {
                btn.classList.remove('selected');
                if (btn.dataset.type === type) {
                    btn.classList.add('selected');
                }
            });
            
            // Reset pagination but keep the search term
            linkSearchOffset = 0;
            // Don't reset currentLinkSearchTerm here - we want to keep the search context
            
            // Check if there's a search term - look for either search input
            const searchInput = document.getElementById('existing-actor-search') || document.getElementById('actor-search-input');
            const searchTerm = searchInput ? searchInput.value.trim() : '';
            
            // Force a fresh search when filter changes
            if (searchTerm && searchTerm.length >= 2) {
                // Set the current search term to maintain context
                currentLinkSearchTerm = searchTerm;
                searchExistingActors();
            } else {
                // Filter actors locally if no search
                if (type === 'all') {
                    filteredExistingActors = existingActors;
                } else {
                    filteredExistingActors = existingActors.filter(a => a.actor_type === type);
                }
                
                // Redisplay
                displayLinkActors(filteredExistingActors);
            }
        }
        
        // Store actor data for quick access
        let linkModalActorCache = {};
        
        // Toggle actor details in link modal
        async function toggleActorDetails(actorId) {
            console.log('toggleActorDetails called for actor:', actorId);
            const detailsRow = document.getElementById(`details-${actorId}`);
            const toggleBtn = document.getElementById(`toggle-btn-${actorId}`);
            const contentDiv = document.getElementById(`actor-details-content-${actorId}`);
            
            console.log('detailsRow found:', !!detailsRow);
            console.log('toggleBtn found:', !!toggleBtn);
            console.log('contentDiv found:', !!contentDiv);
            
            if (!detailsRow) {
                console.error('Details row not found for actor:', actorId);
                return;
            }
            
            console.log('Current display state:', detailsRow.style.display);
            console.log('Current innerHTML length:', contentDiv ? contentDiv.innerHTML.length : 0);
            console.log('Current innerHTML:', contentDiv ? contentDiv.innerHTML : 'no content div');
            
            if (detailsRow.style.display === 'none' || detailsRow.style.display === '') {
                // Show details
                console.log('Showing details row');
                detailsRow.style.display = 'table-row';
                toggleBtn.textContent = '▲ Less';
                
                // Load details if not already loaded
                const hasContent = contentDiv && contentDiv.innerHTML.trim() && contentDiv.innerHTML.trim() !== '<!-- Details will be loaded when expanded -->';
                console.log('Has existing content:', hasContent);
                if (contentDiv && !hasContent) {
                    console.log('Content is empty or placeholder, loading details...');
                    // Check if we have the actor in our cache first
                    let actor = linkModalActorCache[actorId];
                    
                    if (!actor) {
                        // Check in existing actors array
                        actor = existingActors.find(a => a.id === actorId);
                    }
                    
                    if (!actor) {
                        // Check in filtered actors array
                        actor = filteredExistingActors.find(a => a.id === actorId);
                    }
                    
                    if (actor) {
                        // Use cached data
                        contentDiv.innerHTML = formatActorDetails(actor);
                    } else {
                        // Fetch from database
                        contentDiv.innerHTML = '<div class="loading">Loading actor details...</div>';
                        
                        try {
                            const actors = await supabaseRequest(`v2_actors?select=*&id=eq.${actorId}`);
                            if (actors && actors.length > 0) {
                                actor = actors[0];
                                linkModalActorCache[actorId] = actor; // Cache for future use
                                contentDiv.innerHTML = formatActorDetails(actor);
                            } else {
                                contentDiv.innerHTML = '<div class="error-message">Could not load actor details</div>';
                            }
                        } catch (error) {
                            console.error('Error loading actor details:', error);
                            contentDiv.innerHTML = '<div class="error-message">Error loading details</div>';
                        }
                    }
                }
            } else {
                // Hide details
                console.log('Hiding details row');
                detailsRow.style.display = 'none';
                toggleBtn.textContent = '▼ More';
            }
        }
        
        // Format actor details based on type
        function formatActorDetails(actor) {
            let html = '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">';
            
            // Common fields
            html += `
                <div><strong>ID:</strong> ${actor.id}</div>
                <div><strong>Type:</strong> ${actor.actor_type}</div>
                <div><strong>Name:</strong> ${actor.name}</div>
                <div><strong>City:</strong> ${actor.city || 'N/A'}</div>
                <div><strong>State:</strong> ${actor.state || 'N/A'}</div>
                <div><strong>Region:</strong> ${actor.region || 'N/A'}</div>
            `;
            
            // About field (full width)
            if (actor.about) {
                html += `<div style="grid-column: 1 / -1;"><strong>About:</strong> ${actor.about}</div>`;
            }
            
            // Type-specific fields
            if (actor.actor_type === 'person') {
                // Person-specific fields (using custom_text mappings)
                if (actor.custom_text_1) html += `<div><strong>Present Role:</strong> ${actor.custom_text_1}</div>`;
                if (actor.custom_text_2) html += `<div><strong>Role Category:</strong> ${actor.custom_text_2}</div>`;
                if (actor.custom_text_3) html += `<div><strong>Role History:</strong> ${actor.custom_text_3}</div>`;
                if (actor.custom_bool_1 !== null) html += `<div><strong>TPUSA Staff:</strong> ${actor.custom_bool_1 ? 'Yes' : 'No'}</div>`;
                if (actor.custom_bool_2 !== null) html += `<div><strong>TPUSA Affiliated:</strong> ${actor.custom_bool_2 ? 'Yes' : 'No'}</div>`;
            } else if (actor.actor_type === 'organization') {
                // Organization-specific fields
                if (actor.custom_text_1) html += `<div><strong>Organization Type:</strong> ${actor.custom_text_1}</div>`;
                if (actor.custom_text_2) html += `<div><strong>Parent Organization:</strong> ${actor.custom_text_2}</div>`;
                if (actor.custom_text_3) html += `<div><strong>Focus Area:</strong> ${actor.custom_text_3}</div>`;
                if (actor.custom_bool_1 !== null) html += `<div><strong>Is TPUSA:</strong> ${actor.custom_bool_1 ? 'Yes' : 'No'}</div>`;
            } else if (actor.actor_type === 'chapter') {
                // Chapter-specific fields
                if (actor.custom_text_1) html += `<div><strong>School Type:</strong> ${actor.custom_text_1}</div>`;
                if (actor.custom_text_2) html += `<div><strong>Coordinator:</strong> ${actor.custom_text_2}</div>`;
                if (actor.custom_text_3) html += `<div><strong>Email:</strong> ${actor.custom_text_3}</div>`;
                if (actor.custom_numeric_1) html += `<div><strong>Active Members:</strong> ${actor.custom_numeric_1}</div>`;
                if (actor.custom_numeric_2) html += `<div><strong>Founded Year:</strong> ${actor.custom_numeric_2}</div>`;
            }
            
            // Show all custom fields that have values (as fallback)
            for (let i = 1; i <= 10; i++) {
                const textField = actor[`custom_text_${i}`];
                if (textField && !html.includes(textField)) {
                    html += `<div><strong>Custom Text ${i}:</strong> ${textField}</div>`;
                }
            }
            
            // Profile data if available
            if (actor.x_profile_data && Object.keys(actor.x_profile_data).length > 0) {
                html += `<div style="grid-column: 1 / -1;"><strong>X/Twitter Profile:</strong> ${JSON.stringify(actor.x_profile_data).substring(0, 200)}...</div>`;
            }
            if (actor.instagram_profile_data && Object.keys(actor.instagram_profile_data).length > 0) {
                html += `<div style="grid-column: 1 / -1;"><strong>Instagram Profile:</strong> ${JSON.stringify(actor.instagram_profile_data).substring(0, 200)}...</div>`;
            }
            
            // Metadata
            if (actor.data && Object.keys(actor.data).length > 0) {
                html += `<div style="grid-column: 1 / -1;"><strong>Additional Data:</strong> ${JSON.stringify(actor.data, null, 2).substring(0, 500)}...</div>`;
            }
            
            html += '</div>';
            
            // Add timestamps
            html += `
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd; font-size: 11px; color: #666;">
                    <strong>Created:</strong> ${new Date(actor.created_at).toLocaleString()} | 
                    <strong>Updated:</strong> ${new Date(actor.updated_at).toLocaleString()}
                </div>
            `;
            
            return html;
        }
        
        // Toggle suggestion details in link modal
        async function toggleSuggestionDetails(actorId) {
            const detailsDiv = document.getElementById(`suggest-details-${actorId}`);
            const toggleBtn = document.getElementById(`suggest-toggle-btn-${actorId}`);
            const contentDiv = document.getElementById(`suggest-details-content-${actorId}`);
            
            if (!detailsDiv) return;
            
            if (detailsDiv.style.display === 'none') {
                // Show details
                detailsDiv.style.display = 'block';
                toggleBtn.textContent = '▲ Less';
                
                // Load details if not already loaded
                if (contentDiv && !contentDiv.innerHTML.trim()) {
                    // Check if we have the full actor data in cache
                    let actor = linkModalActorCache[actorId];
                    
                    // If we only have partial data from similarity search, fetch full details
                    if (actor && !actor.created_at) {
                        contentDiv.innerHTML = '<div class="loading">Loading full actor details...</div>';
                        try {
                            const actors = await supabaseRequest(`v2_actors?select=*&id=eq.${actorId}`);
                            if (actors && actors.length > 0) {
                                actor = actors[0];
                                linkModalActorCache[actorId] = actor; // Update cache with full data
                                contentDiv.innerHTML = formatActorDetails(actor);
                            } else {
                                contentDiv.innerHTML = '<div class="error-message">Could not load actor details</div>';
                            }
                        } catch (error) {
                            console.error('Error loading suggestion details:', error);
                            contentDiv.innerHTML = '<div class="error-message">Error loading details</div>';
                        }
                    } else if (actor) {
                        // We have full data, use it
                        contentDiv.innerHTML = formatActorDetails(actor);
                    } else {
                        // No cache at all, fetch from database
                        contentDiv.innerHTML = '<div class="loading">Loading actor details...</div>';
                        try {
                            const actors = await supabaseRequest(`v2_actors?select=*&id=eq.${actorId}`);
                            if (actors && actors.length > 0) {
                                actor = actors[0];
                                linkModalActorCache[actorId] = actor;
                                contentDiv.innerHTML = formatActorDetails(actor);
                            } else {
                                contentDiv.innerHTML = '<div class="error-message">Could not load actor details</div>';
                            }
                        } catch (error) {
                            console.error('Error loading suggestion details:', error);
                            contentDiv.innerHTML = '<div class="error-message">Error loading details</div>';
                        }
                    }
                }
            } else {
                // Hide details
                detailsDiv.style.display = 'none';
                toggleBtn.textContent = '▼ More';
            }
        }
        
        // Toggle advanced search visibility
        function toggleAdvancedSearch() {
            const advancedFields = document.getElementById('advanced-search-fields');
            if (advancedFields) {
                advancedFields.style.display = advancedFields.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        // Toggle main tab advanced search
        function toggleMainAdvancedSearch() {
            const advancedFields = document.getElementById('main-advanced-search-fields');
            if (advancedFields) {
                advancedFields.style.display = advancedFields.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        // Perform advanced search in main tab
        async function performMainAdvancedSearch() {
            const searchParams = {
                name: document.getElementById('main-adv-search-name').value.trim(),
                about: document.getElementById('main-adv-search-about').value.trim(),
                city: document.getElementById('main-adv-search-city').value.trim(),
                state: document.getElementById('main-adv-search-state').value.trim(),
                region: document.getElementById('main-adv-search-region').value.trim(),
                type: document.getElementById('main-adv-search-type').value,
                linkedActorId: document.getElementById('main-adv-search-linked-actor-id').value,
                relationship: document.getElementById('main-adv-search-relationship').value,
                bidirectional: document.getElementById('main-adv-search-bidirectional').checked
            };
            
            // Save search state
            sessionStorage.setItem('mainAdvancedSearch', JSON.stringify(searchParams));
            
            // Show active search indicator
            const indicator = document.getElementById('main-active-search-indicator');
            const summary = document.getElementById('main-active-search-summary');
            let summaryParts = [];
            
            if (searchParams.name) summaryParts.push(`Name: "${searchParams.name}"`);
            if (searchParams.type) summaryParts.push(`Type: ${searchParams.type}`);
            if (searchParams.city) summaryParts.push(`City: "${searchParams.city}"`);
            if (searchParams.state) summaryParts.push(`State: "${searchParams.state}"`);
            if (searchParams.linkedActorId) {
                const linkedName = document.getElementById('main-adv-search-linked-actor').value;
                summaryParts.push(`Linked to: "${linkedName}"`);
            }
            
            if (summaryParts.length > 0) {
                summary.textContent = summaryParts.join(', ');
                indicator.style.display = 'block';
            }
            
            // Perform the search
            await performAdvancedMainSearch(searchParams);
        }
        
        // Perform the actual advanced search with parameters
        async function performAdvancedMainSearch(searchParams) {
            try {
                document.getElementById('existing-actors-main-list').innerHTML = '<div class="loading">Searching...</div>';
                
                let results = [];
                
                // Special case: search for actors with no relationships
                if (searchParams.linkedActorId === 'NONE' || searchParams.relationship === 'none') {
                    console.log('Searching for actors with no relationships, type:', searchParams.type);
                    
                    // First get all actors matching other criteria
                    let baseQuery = 'v2_actors?select=*';
                    let conditions = [];
                    
                    // Apply all filter conditions
                    if (searchParams.name) conditions.push(`name=ilike.*${encodeURIComponent(searchParams.name)}*`);
                    if (searchParams.about) conditions.push(`about=ilike.*${encodeURIComponent(searchParams.about)}*`);
                    if (searchParams.city) conditions.push(`city=ilike.*${encodeURIComponent(searchParams.city)}*`);
                    if (searchParams.state) conditions.push(`state=ilike.*${encodeURIComponent(searchParams.state)}*`);
                    if (searchParams.region) conditions.push(`region=ilike.*${encodeURIComponent(searchParams.region)}*`);
                    
                    // IMPORTANT: Apply actor type filter
                    if (searchParams.type && searchParams.type !== '') {
                        conditions.push(`actor_type=eq.${searchParams.type}`);
                        console.log('Added actor type condition:', `actor_type=eq.${searchParams.type}`);
                    }
                    
                    if (conditions.length > 0) {
                        baseQuery += `&${conditions.join('&')}`;
                    }
                    
                    baseQuery += '&order=name&limit=1000';
                    console.log('Query for actors:', baseQuery);
                    
                    const allActors = await supabaseRequest(baseQuery);
                    console.log(`Found ${allActors.length} actors matching criteria`);
                    
                    // Debug: Check actor types in results
                    if (searchParams.type) {
                        const wrongTypes = allActors.filter(a => a.actor_type !== searchParams.type);
                        if (wrongTypes.length > 0) {
                            console.error('ERROR: Found actors with wrong type:', wrongTypes.slice(0, 5).map(a => ({name: a.name, type: a.actor_type})));
                        }
                    }
                    
                    // Get all actors that have any relationships
                    const actorsWithLinks = new Set();
                    const fromLinks = await supabaseRequest('v2_actor_links?select=from_actor_id');
                    const toLinks = await supabaseRequest('v2_actor_links?select=to_actor_id');
                    
                    fromLinks.forEach(link => actorsWithLinks.add(link.from_actor_id));
                    toLinks.forEach(link => actorsWithLinks.add(link.to_actor_id));
                    
                    console.log(`Found ${actorsWithLinks.size} actors with relationships`);
                    
                    // Filter to only actors with no relationships AND ensure type filter is applied
                    results = allActors.filter(actor => {
                        const hasNoLinks = !actorsWithLinks.has(actor.id);
                        const matchesType = !searchParams.type || actor.actor_type === searchParams.type;
                        return hasNoLinks && matchesType;
                    });
                    
                    console.log(`Found ${results.length} actors with no relationships after filtering`);
                    
                } else if (searchParams.linkedActorId) {
                    // Search for actors linked to a specific actor
                    let linkedActorIds = new Set();
                    
                    // Get actors linked FROM the specified actor
                    const fromLinks = await supabaseRequest(`v2_actor_links?from_actor_id=eq.${searchParams.linkedActorId}&select=to_actor_id${searchParams.relationship && searchParams.relationship !== 'none' ? `&relationship=eq.${searchParams.relationship}` : ''}`);
                    fromLinks.forEach(link => linkedActorIds.add(link.to_actor_id));
                    
                    // If bidirectional, also get actors linked TO the specified actor
                    if (searchParams.bidirectional) {
                        const toLinks = await supabaseRequest(`v2_actor_links?to_actor_id=eq.${searchParams.linkedActorId}&select=from_actor_id${searchParams.relationship && searchParams.relationship !== 'none' ? `&relationship=eq.${searchParams.relationship}` : ''}`);
                        toLinks.forEach(link => linkedActorIds.add(link.from_actor_id));
                    }
                    
                    if (linkedActorIds.size > 0) {
                        // Get actor details for linked actors
                        const actorIdsArray = Array.from(linkedActorIds);
                        for (let i = 0; i < actorIdsArray.length; i += 50) {
                            const batch = actorIdsArray.slice(i, i + 50);
                            let linkedQuery = `v2_actors?select=*&id=in.(${batch.join(',')})`;
                            
                            // Apply other filters
                            let conditions = [];
                            if (searchParams.name) conditions.push(`name=ilike.*${encodeURIComponent(searchParams.name)}*`);
                            if (searchParams.about) conditions.push(`about=ilike.*${encodeURIComponent(searchParams.about)}*`);
                            if (searchParams.city) conditions.push(`city=ilike.*${encodeURIComponent(searchParams.city)}*`);
                            if (searchParams.state) conditions.push(`state=ilike.*${encodeURIComponent(searchParams.state)}*`);
                            if (searchParams.region) conditions.push(`region=ilike.*${encodeURIComponent(searchParams.region)}*`);
                            if (searchParams.type) conditions.push(`actor_type.eq.${searchParams.type}`);
                            
                            if (conditions.length > 0) {
                                linkedQuery += `&${conditions.join('&')}`;
                            }
                            
                            const batchResults = await supabaseRequest(linkedQuery);
                            results.push(...batchResults);
                        }
                    }
                } else {
                    // Regular search without linked actor filter
                    let query = 'v2_actors?select=*';
                    let conditions = [];
                    
                    if (searchParams.name) conditions.push(`name=ilike.*${encodeURIComponent(searchParams.name)}*`);
                    if (searchParams.about) conditions.push(`about=ilike.*${encodeURIComponent(searchParams.about)}*`);
                    if (searchParams.city) conditions.push(`city=ilike.*${encodeURIComponent(searchParams.city)}*`);
                    if (searchParams.state) conditions.push(`state=ilike.*${encodeURIComponent(searchParams.state)}*`);
                    if (searchParams.region) conditions.push(`region=ilike.*${encodeURIComponent(searchParams.region)}*`);
                    if (searchParams.type) conditions.push(`actor_type.eq.${searchParams.type}`);
                    
                    if (conditions.length > 0) {
                        query += `&${conditions.join('&')}`;
                    }
                    
                    query += '&order=name&limit=200';
                    results = await supabaseRequest(query);
                }
                
                // Display results
                displayExistingMainActors(results);
                
            } catch (error) {
                console.error('Error in advanced search:', error);
                document.getElementById('existing-actors-main-list').innerHTML = `<div class="error">Error: ${error.message}</div>`;
            }
        }
        
        // Display actors in the main existing actors list
        function displayExistingMainActors(actors) {
            const listDiv = document.getElementById('existing-actors-main-list');
            
            if (!actors || actors.length === 0) {
                listDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No actors found matching your search criteria</div>';
                return;
            }
            
            let html = '<table class="results-table">';
            html += '<thead><tr><th>Type</th><th>Name</th><th>Location</th><th>Actions</th></tr></thead>';
            html += '<tbody>';
            
            actors.forEach(actor => {
                const location = [actor.city, actor.state].filter(Boolean).join(', ') || 'Unknown';
                const typeIcon = actor.actor_type === 'person' ? '👤' : 
                                actor.actor_type === 'organization' ? '🏢' : '📍';
                
                html += `
                    <tr>
                        <td>${typeIcon} ${actor.actor_type}</td>
                        <td><strong>${actor.name}</strong></td>
                        <td>${location}</td>
                        <td>
                            <button class="action-btn" onclick="openEditActorModal('${actor.id}')">✏️ Edit</button>
                            <button class="action-btn link" onclick="viewActorRelationships('${actor.id}')">🔗 Links</button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            
            if (actors.length === 200) {
                html += '<div style="padding: 10px; text-align: center; background: #f8f9fa; margin-top: 10px;">Showing first 200 results. Please refine your search for more specific results.</div>';
            }
            
            listDiv.innerHTML = html;
        }
        
        // Function stubs for actions - implement these based on your needs
        function viewActorRelationships(actorId) {
            // Open modal or navigate to show actor relationships
            console.log('View relationships for actor:', actorId);
            // You can implement this to show the relationships modal
        }
        
        // Clear main tab advanced search
        function clearMainAdvancedSearch() {
            document.getElementById('main-adv-search-name').value = '';
            document.getElementById('main-adv-search-about').value = '';
            document.getElementById('main-adv-search-city').value = '';
            document.getElementById('main-adv-search-state').value = '';
            document.getElementById('main-adv-search-region').value = '';
            document.getElementById('main-adv-search-type').value = '';
            document.getElementById('main-adv-search-linked-actor').value = '';
            document.getElementById('main-adv-search-linked-actor-id').value = '';
            document.getElementById('main-adv-search-relationship').value = '';
            document.getElementById('main-adv-search-bidirectional').checked = true;
            
            sessionStorage.removeItem('mainAdvancedSearch');
            document.getElementById('main-active-search-indicator').style.display = 'none';
            
            // Reset to default view
            loadExistingActors();
        }
        
        // Search for linked actors in main tab
        async function searchMainLinkedActorSuggestions(query) {
            clearTimeout(linkedActorSearchTimeout);
            const suggestionsDiv = document.getElementById('main-linked-actor-suggestions');
            
            if (!query || query.length < 2) {
                suggestionsDiv.style.display = 'none';
                return;
            }
            
            linkedActorSearchTimeout = setTimeout(async () => {
                try {
                    const results = await supabaseRequest(`v2_actors?select=id,name,actor_type,city,state&or=(name=ilike.*${encodeURIComponent(query)}*,city=ilike.*${encodeURIComponent(query)}*)&order=name&limit=10`);
                    
                    if (results.length > 0) {
                        let html = '';
                        results.forEach(actor => {
                            const location = [actor.city, actor.state].filter(Boolean).join(', ') || 'Unknown';
                            html += `
                                <div style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee;"
                                     onmouseover="this.style.background='#f0f0f0'"
                                     onmouseout="this.style.background='white'"
                                     onclick="selectMainLinkedActor('${actor.id}', '${actor.name.replace(/'/g, "\\'")}')">
                                    <strong>${actor.name}</strong>
                                    <small style="color: #666; display: block;">
                                        ${actor.actor_type} • ${location}
                                    </small>
                                </div>
                            `;
                        });
                        
                        suggestionsDiv.innerHTML = html;
                        suggestionsDiv.style.display = 'block';
                    } else {
                        suggestionsDiv.innerHTML = '<div style="padding: 8px; color: #666;">No actors found</div>';
                        suggestionsDiv.style.display = 'block';
                    }
                } catch (error) {
                    console.error('Error searching for linked actors:', error);
                }
            }, 300);
        }
        
        function selectMainLinkedActor(actorId, actorName) {
            document.getElementById('main-adv-search-linked-actor').value = actorName;
            document.getElementById('main-adv-search-linked-actor-id').value = actorId;
            document.getElementById('main-linked-actor-suggestions').style.display = 'none';
        }
        
        // Clear advanced search fields
        function clearAdvancedSearch() {
            document.getElementById('adv-search-name').value = '';
            document.getElementById('adv-search-about').value = '';
            document.getElementById('adv-search-city').value = '';
            document.getElementById('adv-search-state').value = '';
            document.getElementById('adv-search-region').value = '';
            document.getElementById('adv-search-type').value = '';
            document.getElementById('adv-search-linked-actor').value = '';
            document.getElementById('adv-search-linked-actor-id').value = '';
            document.getElementById('adv-search-relationship').value = '';
            document.getElementById('adv-search-bidirectional').checked = true;
            document.getElementById('adv-search-school').value = '';
            document.getElementById('adv-search-role').value = '';
            
            // Clear persistent state
            sessionStorage.removeItem('advancedActorSearch');
            currentAdvancedSearchState = null;
            
            // Hide active search indicator
            document.getElementById('active-search-indicator').style.display = 'none';
            
            // Reset advanced search state
            currentAdvancedSearchCriteria = null;
            advancedSearchOffset = 0;
            
            // Reset to showing all actors
            linkSearchOffset = 0;
            loadExistingActors();
        }
        
        // Store current advanced search criteria for pagination
        let currentAdvancedSearchCriteria = null;
        let advancedSearchOffset = 0;
        
        // Perform advanced search with specific fields
        // Global state for advanced search
        let currentAdvancedSearchState = null;
        // Note: selectedLinkedActors already declared earlier in the file
        
        // Persist and restore advanced search state
        function saveAdvancedSearchState() {
            const state = {
                name: document.getElementById('adv-search-name').value.trim(),
                about: document.getElementById('adv-search-about').value.trim(),
                city: document.getElementById('adv-search-city').value.trim(),
                state: document.getElementById('adv-search-state').value.trim(),
                region: document.getElementById('adv-search-region').value.trim(),
                type: document.getElementById('adv-search-type').value,
                linkedActorId: document.getElementById('adv-search-linked-actor-id').value,
                linkedActorName: document.getElementById('adv-search-linked-actor').value,
                relationship: document.getElementById('adv-search-relationship').value,
                bidirectional: document.getElementById('adv-search-bidirectional').checked,
                school: document.getElementById('adv-search-school').value.trim(),
                role: document.getElementById('adv-search-role').value.trim(),
                isActive: true
            };
            
            currentAdvancedSearchState = state;
            sessionStorage.setItem('advancedActorSearch', JSON.stringify(state));
        }
        
        function restoreAdvancedSearchState() {
            const saved = sessionStorage.getItem('advancedActorSearch');
            if (saved) {
                const state = JSON.parse(saved);
                document.getElementById('adv-search-name').value = state.name || '';
                document.getElementById('adv-search-about').value = state.about || '';
                document.getElementById('adv-search-city').value = state.city || '';
                document.getElementById('adv-search-state').value = state.state || '';
                document.getElementById('adv-search-region').value = state.region || '';
                document.getElementById('adv-search-type').value = state.type || '';
                document.getElementById('adv-search-linked-actor-id').value = state.linkedActorId || '';
                document.getElementById('adv-search-linked-actor').value = state.linkedActorName || '';
                document.getElementById('adv-search-relationship').value = state.relationship || '';
                document.getElementById('adv-search-bidirectional').checked = state.bidirectional !== false;
                document.getElementById('adv-search-school').value = state.school || '';
                document.getElementById('adv-search-role').value = state.role || '';
                
                if (state.isActive) {
                    showActiveSearchIndicator(state);
                    performAdvancedActorSearch();
                }
            }
        }
        
        function showActiveSearchIndicator(state) {
            const indicator = document.getElementById('active-search-indicator');
            const summary = document.getElementById('active-search-summary');
            
            let summaryParts = [];
            if (state.name) summaryParts.push(`Name: "${state.name}"`);
            if (state.type) summaryParts.push(`Type: ${state.type}`);
            if (state.city) summaryParts.push(`City: "${state.city}"`);
            if (state.state) summaryParts.push(`State: "${state.state}"`);
            if (state.linkedActorName) summaryParts.push(`Linked to: "${state.linkedActorName}"`);
            if (state.relationship) summaryParts.push(`Relationship: ${state.relationship}`);
            
            if (summaryParts.length > 0) {
                summary.textContent = summaryParts.join(', ');
                indicator.style.display = 'block';
            } else {
                indicator.style.display = 'none';
            }
        }
        
        async function performAdvancedActorSearch(isLoadMore = false) {
            const name = document.getElementById('adv-search-name').value.trim();
            const about = document.getElementById('adv-search-about').value.trim();
            const city = document.getElementById('adv-search-city').value.trim();
            const state = document.getElementById('adv-search-state').value.trim();
            const region = document.getElementById('adv-search-region').value.trim();
            const type = document.getElementById('adv-search-type').value;
            const linkedActorId = document.getElementById('adv-search-linked-actor-id').value;
            const relationship = document.getElementById('adv-search-relationship').value;
            const bidirectional = document.getElementById('adv-search-bidirectional').checked;
            const school = document.getElementById('adv-search-school').value.trim();
            const role = document.getElementById('adv-search-role').value.trim();
            
            if (!isLoadMore) {
                // Validate at least one criterion
                if (!name && !about && !city && !state && !region && !type && !linkedActorId && !school && !role) {
                    alert('Please enter at least one search criterion');
                    return;
                }
                
                // Save state for persistence
                saveAdvancedSearchState();
                
                // Store criteria for pagination
                currentAdvancedSearchCriteria = { name, about, city, state, region, type, linkedActorId, relationship, bidirectional, school, role };
                advancedSearchOffset = 0;
                existingActors = [];
                filteredExistingActors = [];
            }
            
            try {
                if (!isLoadMore) {
                    document.getElementById('link-actors-tbody').innerHTML = '<tr><td colspan="4" style="text-align: center;">Searching...</td></tr>';
                }
                
                // Build query with specific field filters
                let conditions = [];
                const criteria = currentAdvancedSearchCriteria || { name, about, city, state, region, type, linkedActorId, relationship, bidirectional, school, role };
                
                // Basic text searches
                if (criteria.name) conditions.push(`name=ilike.*${encodeURIComponent(criteria.name)}*`);
                if (criteria.about) conditions.push(`about=ilike.*${encodeURIComponent(criteria.about)}*`);
                if (criteria.city) conditions.push(`city=ilike.*${encodeURIComponent(criteria.city)}*`);
                if (criteria.state) conditions.push(`state=ilike.*${encodeURIComponent(criteria.state)}*`);
                if (criteria.region) conditions.push(`region=ilike.*${encodeURIComponent(criteria.region)}*`);
                
                // Custom field searches
                if (criteria.school) conditions.push(`custom_text_1=ilike.*${encodeURIComponent(criteria.school)}*`);
                if (criteria.role) conditions.push(`custom_text_2=ilike.*${encodeURIComponent(criteria.role)}*`);
                
                // Actor type filter
                if (criteria.type) conditions.push(`actor_type.eq.${criteria.type}`);
                
                let results = [];
                
                // Handle linked actor search
                if (criteria.linkedActorId) {
                    // Search for actors linked to the specified actor
                    let linkedActorIds = new Set();
                    
                    // Get actors linked FROM the specified actor
                    const fromLinks = await supabaseRequest(`v2_actor_links?from_actor_id=eq.${criteria.linkedActorId}&select=to_actor_id${criteria.relationship ? `&relationship=eq.${criteria.relationship}` : ''}`);
                    fromLinks.forEach(link => linkedActorIds.add(link.to_actor_id));
                    
                    // If bidirectional, also get actors linked TO the specified actor
                    if (criteria.bidirectional) {
                        const toLinks = await supabaseRequest(`v2_actor_links?to_actor_id=eq.${criteria.linkedActorId}&select=from_actor_id${criteria.relationship ? `&relationship=eq.${criteria.relationship}` : ''}`);
                        toLinks.forEach(link => linkedActorIds.add(link.from_actor_id));
                    }
                    
                    if (linkedActorIds.size > 0) {
                        // Now get the actor details for linked actors, applying other filters
                        const actorIdsArray = Array.from(linkedActorIds);
                        const batchSize = 50; // Process in batches to avoid URL length limits
                        
                        for (let i = 0; i < actorIdsArray.length; i += batchSize) {
                            const batch = actorIdsArray.slice(i, i + batchSize);
                            let linkedQuery = `v2_actors?select=*&id=in.(${batch.join(',')})`;
                            
                            // Apply other filters to the linked actors
                            if (conditions.length > 0) {
                                linkedQuery += `&${conditions.join('&')}`;
                            }
                            
                            const batchResults = await supabaseRequest(linkedQuery);
                            results.push(...batchResults);
                        }
                    }
                } else {
                    // Regular search without linked actor filter
                    let query = `v2_actors?select=*`;
                    
                    if (conditions.length > 0) {
                        query += `&${conditions.join('&')}`;
                    }
                    
                    if (currentActorTypeFilter !== 'all' && !criteria.type) {
                        query += `&actor_type=eq.${currentActorTypeFilter}`;
                    }
                    
                    query += `&order=name&limit=${linkSearchLimit}&offset=${advancedSearchOffset}`;
                    
                    results = await supabaseRequest(query);
                }
                
                // Check if there are more results
                hasMoreLinkResults = results.length === linkSearchLimit;
                advancedSearchOffset += results.length;
                
                if (isLoadMore) {
                    existingActors = [...existingActors, ...results];
                    filteredExistingActors = [...filteredExistingActors, ...results];
                    displayLinkActors(results, true); // Append mode
                } else {
                    existingActors = results;
                    filteredExistingActors = results;
                    displayLinkActors(filteredExistingActors, false);
                }
                
                if (!isLoadMore && results.length === 0) {
                    document.getElementById('link-actors-tbody').innerHTML = '<tr><td colspan="4" style="text-align: center;">No actors found matching your criteria</td></tr>';
                }
                
            } catch (error) {
                console.error('Error in advanced search:', error);
                alert('Error performing advanced search: ' + error.message);
            }
        }
        
        // Search for linked actor suggestions
        let linkedActorSearchTimeout = null;
        async function searchLinkedActorSuggestions(query) {
            clearTimeout(linkedActorSearchTimeout);
            const suggestionsDiv = document.getElementById('linked-actor-suggestions');
            
            if (!query || query.length < 2) {
                suggestionsDiv.style.display = 'none';
                return;
            }
            
            linkedActorSearchTimeout = setTimeout(async () => {
                try {
                    // Search for actors matching the query
                    const results = await supabaseRequest(`v2_actors?select=id,name,actor_type,city,state&or=(name=ilike.*${encodeURIComponent(query)}*,city=ilike.*${encodeURIComponent(query)}*)&order=name&limit=10`);
                    
                    if (results.length > 0) {
                        let html = '';
                        results.forEach(actor => {
                            const location = [actor.city, actor.state].filter(Boolean).join(', ') || 'Unknown';
                            html += `
                                <div style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee;"
                                     onmouseover="this.style.background='#f0f0f0'"
                                     onmouseout="this.style.background='white'"
                                     onclick="selectLinkedActor('${actor.id}', '${actor.name.replace(/'/g, "\\'")}')">
                                    <strong>${actor.name}</strong>
                                    <small style="color: #666; display: block;">
                                        ${actor.actor_type} • ${location}
                                    </small>
                                </div>
                            `;
                        });
                        
                        suggestionsDiv.innerHTML = html;
                        suggestionsDiv.style.display = 'block';
                    } else {
                        suggestionsDiv.innerHTML = '<div style="padding: 8px; color: #666;">No actors found</div>';
                        suggestionsDiv.style.display = 'block';
                    }
                } catch (error) {
                    console.error('Error searching for linked actors:', error);
                }
            }, 300);
        }
        
        function selectLinkedActor(actorId, actorName) {
            document.getElementById('adv-search-linked-actor').value = actorName;
            document.getElementById('adv-search-linked-actor-id').value = actorId;
            document.getElementById('linked-actor-suggestions').style.display = 'none';
        }
        
        // Hide suggestions when clicking outside
        document.addEventListener('click', function(event) {
            const suggestionsDiv = document.getElementById('linked-actor-suggestions');
            const searchInput = document.getElementById('adv-search-linked-actor');
            
            if (suggestionsDiv && searchInput && 
                !suggestionsDiv.contains(event.target) && 
                event.target !== searchInput) {
                suggestionsDiv.style.display = 'none';
            }
        });
        
        // Search actors for linking
        async function searchActorsForLink(searchTerm) {
            if (!searchTerm || searchTerm.length < 2) {
                // Reset to showing all actors of current type
                filterLinkActorType(currentActorTypeFilter);
                return;
            }
            
            searchTerm = searchTerm.toLowerCase();
            
            // Filter existing actors
            let filtered = existingActors.filter(actor => {
                const nameMatch = actor.name && actor.name.toLowerCase().includes(searchTerm);
                const cityMatch = actor.city && actor.city.toLowerCase().includes(searchTerm);
                const stateMatch = actor.state && actor.state.toLowerCase().includes(searchTerm);
                const aboutMatch = actor.about && actor.about.toLowerCase().includes(searchTerm);
                
                return nameMatch || cityMatch || stateMatch || aboutMatch;
            });
            
            // Apply type filter if not 'all'
            if (currentActorTypeFilter !== 'all') {
                filtered = filtered.filter(a => a.actor_type === currentActorTypeFilter);
            }
            
            filteredExistingActors = filtered;
            displayLinkActors(filtered);
        }
        
        // Select an actor for linking
        function selectLinkActor(actorId) {
            console.log('selectLinkActor called with actorId:', actorId);
            
            // Remove previous selection
            document.querySelectorAll('#link-actors-tbody tr').forEach(row => {
                row.style.backgroundColor = '';
            });
            
            // Highlight selected row
            const selectedRow = document.querySelector(`#link-actors-tbody tr[data-actor-id="${actorId}"]`);
            if (selectedRow) {
                selectedRow.style.backgroundColor = '#e3f2fd';
            }
            
            // Find and set selected actor (search in both arrays)
            let actor = existingActors.find(a => a.id === actorId);
            if (!actor) {
                // If not found in existingActors, try filteredExistingActors
                actor = filteredExistingActors.find(a => a.id === actorId);
            }
            console.log('Found actor:', actor);
            console.log('Searched in existingActors:', existingActors.length, 'actors');
            console.log('Searched in filteredExistingActors:', filteredExistingActors.length, 'actors');
            if (actor) {
                selectedExistingActor = actor;
                console.log('Set selectedExistingActor to:', selectedExistingActor);
                showActorPreview(actor);
                
                // Enable link button
                const linkButton = document.getElementById('link-actor-button');
                console.log('Link button found:', !!linkButton);
                if (linkButton) {
                    linkButton.disabled = false;
                    console.log('Link button enabled');
                }
            } else {
                console.error('Actor not found in existingActors array');
            }
        }

        // Display existing actors (removed - now using displayLinkActors)


        // Confirm link to existing using V2 function
        async function confirmLinkToExisting() {
            console.log('confirmLinkToExisting called');
            console.log('selectedExistingActor:', selectedExistingActor);
            console.log('currentUnknownActor:', currentUnknownActor);
            
            if (!selectedExistingActor) {
                console.error('No selectedExistingActor');
                alert('Please select an actor from the list');
                return;
            }

            try {
                // Debug logging
                console.log('Unknown Actor:', currentUnknownActor);
                console.log('Unknown Actor ID:', currentUnknownActor.id);
                console.log('Selected Existing Actor:', selectedExistingActor);
                console.log('Existing Actor ID:', selectedExistingActor.id);
                
                // Validate UUIDs
                const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                if (!uuidRegex.test(currentUnknownActor.id)) {
                    throw new Error(`Invalid unknown actor ID format: ${currentUnknownActor.id}`);
                }
                if (!uuidRegex.test(selectedExistingActor.id)) {
                    throw new Error(`Invalid existing actor ID format: ${selectedExistingActor.id}`);
                }
                
                const linkResult = await callSupabaseFunction('link_v2_unknown_to_existing', {
                    p_unknown_actor_id: currentUnknownActor.id,
                    p_existing_actor_id: selectedExistingActor.id
                });
                
                console.log('Function link_v2_unknown_to_existing returned:', linkResult);
                
                // Verify the actor was actually updated
                const verifyUpdate = await supabaseRequest(`v2_unknown_actors?select=id,review_status,assigned_actor_id&id=eq.${currentUnknownActor.id}`);
                console.log('Verification - Actor status after linking:', verifyUpdate);

                alert('Successfully linked to existing actor! All links have been migrated automatically.');
                
                closeModal('link-modal');
                
                // Reload the current view or search results
                console.log('Current view:', currentView);
                
                // Check what's currently displayed in the results header
                const resultsContainer = document.getElementById('results-container');
                const currentTitle = resultsContainer ? resultsContainer.querySelector('h3')?.textContent : '';
                console.log('Current results title:', currentTitle);
                
                // Try to reload based on current search
                const searchBox = document.querySelector('input[type="text"][placeholder*="Search"]');
                const currentSearch = searchBox ? searchBox.value : '';
                console.log('Current search term:', currentSearch);
                
                // Check if network filter is active first
                if (networkFilterActive) {
                    console.log('Reloading network filter');
                    await applyNetworkFilter();
                } else if (currentSearch) {
                    // Reload the search by triggering the search function
                    console.log('Reloading search for:', currentSearch);
                    // Find and click the search button or trigger search
                    const searchButton = document.querySelector('button[onclick*="performSearch"]');
                    if (searchButton) {
                        searchButton.click();
                    } else {
                        // Try to call performSearch directly
                        if (typeof window.performSearch === 'function') {
                            window.performSearch();
                        } else if (currentView && currentView.id) {
                            await loadActorsWithView(currentView.id, currentView.config || currentView.filter_config);
                        }
                    }
                } else if (currentView && currentView.id) {
                    console.log('Reloading view:', currentView.id);
                    await loadActorsWithView(currentView.id, currentView.config || currentView.filter_config);
                } else {
                    // Fallback to reload all unknown actors
                    console.log('Fallback: reloading all unknown actors');
                    await loadActorsWithView('all', { filter: 'all' });
                }

            } catch (error) {
                console.error('Error linking to existing actor:', error);
                alert('Error linking to existing actor: ' + error.message);
            }
        }

        // Search functions
        function debouncedSearchActors() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(searchExistingActors, 300);
        }

        async function searchExistingActors(isLoadMore = false) {
            if (isLoadingLinkSearch && isLoadMore) return;
            
            // Check for either search input ID
            const searchInput = document.getElementById('existing-actor-search') || document.getElementById('actor-search-input');
            const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
            
            // If search term changed, reset
            if (searchTerm !== currentLinkSearchTerm && !isLoadMore) {
                linkSearchOffset = 0;
                filteredExistingActors = [];
                currentLinkSearchTerm = searchTerm;
            }
            
            if (!searchTerm || searchTerm.length < 2) {
                if (!isLoadMore) {
                    linkSearchOffset = 0;
                    filteredExistingActors = currentActorTypeFilter === 'all' ? 
                        existingActors : 
                        existingActors.filter(a => a.actor_type === currentActorTypeFilter);
                    displayLinkActors(filteredExistingActors);
                }
                return;
            }

            try {
                if (!isLoadMore) {
                    const tbody = document.getElementById('link-actors-tbody');
                    if (tbody) {
                        tbody.innerHTML = '<tr><td colspan="4" style="text-align: center;">Searching all actors...</td></tr>';
                    }
                }
                isLoadingLinkSearch = true;

                // Search multiple fields for comprehensive results - use * for PostgREST wildcard
                // Include custom_text fields which may contain emails, school names, etc.
                // Note: Don't encode the search term as it breaks PostgreSQL's ilike pattern matching for spaces
                let query = `v2_actors?select=*&or=(name=ilike.*${encodeURIComponent(searchTerm)}*,about=ilike.*${encodeURIComponent(searchTerm)}*,city=ilike.*${encodeURIComponent(searchTerm)}*,state=ilike.*${encodeURIComponent(searchTerm)}*,region=ilike.*${encodeURIComponent(searchTerm)}*,custom_text_1=ilike.*${encodeURIComponent(searchTerm)}*,custom_text_2=ilike.*${encodeURIComponent(searchTerm)}*,custom_text_3=ilike.*${encodeURIComponent(searchTerm)}*,custom_text_4=ilike.*${encodeURIComponent(searchTerm)}*,custom_text_5=ilike.*${encodeURIComponent(searchTerm)}*)`;
                
                if (currentActorTypeFilter !== 'all') {
                    query += `&actor_type=eq.${currentActorTypeFilter}`;
                }
                
                // Simple pagination without complex scoring
                query += `&order=name&limit=${linkSearchLimit}&offset=${linkSearchOffset}`;
                
                const results = await supabaseRequest(query);
                hasMoreLinkResults = results.length === linkSearchLimit;
                linkSearchOffset += results.length;
                
                if (isLoadMore) {
                    filteredExistingActors = [...filteredExistingActors, ...results];
                    displayLinkActors(results, true); // append mode
                } else {
                    filteredExistingActors = results;
                    displayLinkActors(filteredExistingActors);
                }

            } catch (error) {
                console.error('Error searching actors:', error);
                if (!isLoadMore) {
                    const tbody = document.getElementById('link-actors-tbody');
                    if (tbody) {
                        tbody.innerHTML = 
                            `<tr><td colspan="4" style="text-align: center; color: red;">Error searching actors: ${error.message}</td></tr>`;
                    }
                }
            } finally {
                isLoadingLinkSearch = false;
            }
        }

        // Unknown actors search
        function debouncedUnknownActorSearch() {
            clearTimeout(globalSearchTimeout);
            globalSearchTimeout = setTimeout(performUnknownActorSearch, 300);
        }

        async function performUnknownActorSearch() {
            const searchTerm = document.getElementById('unknown-actors-search').value.toLowerCase().trim();
            
            if (!searchTerm) {
                document.getElementById('results-container').style.display = 'none';
                return;
            }

            if (searchTerm.length < 2) {
                document.getElementById('results-container').style.display = 'none';
                return;
            }

            try {
                // Show results container and loading
                document.getElementById('results-container').style.display = 'block';
                document.getElementById('results-title').textContent = `Searching for "${searchTerm}"...`;
                document.getElementById('results-content').innerHTML = '<div class="loading">Searching unknown actors...</div>';

                // Clear active button states
                document.querySelectorAll('.search-btn').forEach(btn => btn.classList.remove('active'));
                
                // Search v2_unknown_actors - include all possible username fields
                // Search in detected_username and all profile data username fields
                // Filter to only show pending actors (not linked or classified)
                const searchQuery = `v2_unknown_actors?select=*&review_status=eq.pending&or=(detected_username=ilike.*${searchTerm}*,profile_displayname=ilike.*${searchTerm}*,profile_bio=ilike.*${searchTerm}*,x_profile_data->>username=ilike.*${searchTerm}*,instagram_profile_data->>username=ilike.*${searchTerm}*,tiktok_profile_data->>username=ilike.*${searchTerm}*,youtube_profile_data->>username=ilike.*${searchTerm}*,truth_social_profile_data->>username=ilike.*${searchTerm}*)&order=mention_count.desc&limit=200`;
                
                const data = await supabaseRequest(searchQuery);
                
                // Apply frontend filters
                let filteredData = data.filter(actor => {
                    if (actor.x_profile_data && actor.x_profile_data.is_placeholder === true) {
                        return false;
                    }
                    // Don't filter out actors without display names in search results
                    // User is explicitly searching, so show all matches
                    return true;
                });
                
                displayResults(filteredData, 'search', searchTerm, false);

            } catch (error) {
                console.error('Error performing global search:', error);
                document.getElementById('results-content').innerHTML = 
                    '<div class="error-message">Error searching unknown actors: ' + error.message + '</div>';
            }
        }

        function clearUnknownActorSearch() {
            document.getElementById('unknown-actors-search').value = '';
            document.getElementById('results-container').style.display = 'none';
            
            // Clear any active button states
            document.querySelectorAll('.search-btn').forEach(btn => btn.classList.remove('active'));
        }

        // Store usernames for new actor
        let newActorUsernames = [];

        // Create new actor modal functions
        function openCreateActorModal() {
            selectedActorType = null;
            newActorUsernames = []; // Reset usernames
            document.querySelectorAll('#create-actor-content .actor-type-btn').forEach(btn => btn.classList.remove('selected'));
            document.getElementById('create-actor-form').style.display = 'none';
            document.getElementById('create-actor-modal').style.display = 'block';
        }
        
        // Add username to the list for new actor creation
        window.addNewActorUsername = function() {
            const platformElement = document.getElementById('create-actor-username-platform');
            const usernameElement = document.getElementById('create-actor-username-input');
            
            if (!platformElement || !usernameElement) {
                console.error('Form elements not found');
                return;
            }
            
            const platform = platformElement.value;
            const username = usernameElement.value.trim();
            
            console.log('Adding username:', { platform, username }); // Debug log
            
            if (!platform || !username) {
                alert('Please select a platform and enter a username');
                return;
            }
            
            // Check for duplicates
            const exists = newActorUsernames.some(u => u.platform === platform && u.username === username);
            if (exists) {
                alert('This username has already been added');
                return;
            }
            
            // Add to array
            newActorUsernames.push({ platform, username });
            console.log('Current usernames array:', newActorUsernames); // Debug log
            
            // Update display
            updateNewUsernamesDisplay();
            
            // Clear inputs - keep platform selected for convenience
            usernameElement.value = '';
            // Optionally clear platform too: platformElement.value = '';
        }
        
        // Remove username from the list
        window.removeNewUsername = function(index) {
            newActorUsernames.splice(index, 1);
            updateNewUsernamesDisplay();
        }
        
        // Update the display of added usernames
        function updateNewUsernamesDisplay() {
            const container = document.getElementById('new-usernames-list');
            if (!container) return;
            
            if (newActorUsernames.length === 0) {
                container.innerHTML = '<p style="color: #666; margin: 5px 0;">No usernames added yet</p>';
            } else {
                container.innerHTML = newActorUsernames.map((u, index) => `
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 8px; margin: 5px 0; background: white; border: 1px solid #ddd; border-radius: 4px;">
                        <span><strong>${u.platform}:</strong> @${u.username}</span>
                        <button type="button" class="btn btn-sm" onclick="removeNewUsername(${index})" style="padding: 2px 8px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer;">Remove</button>
                    </div>
                `).join('');
            }
        }

        function selectNewActorType(type) {
            selectedActorType = type;
            
            // Update button states
            document.querySelectorAll('#create-actor-content .actor-type-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.closest('.actor-type-btn').classList.add('selected');

            // Don't reset usernames when switching actor types
            // Generate form
            generateCreateActorForm(type);
        }

        async function generateCreateActorForm(type) {
            // Load data if needed
            if (type === 'person' && organizations.length === 0) {
                await loadOrganizations();
            }
            
            if (type === 'person' && existingRoleCategories.length === 0) {
                await loadExistingRoleCategories();
            }

            let formHTML = '<div id="create-success-message" style="display: none;"></div>';

            // Add username fields at the top for all types
            formHTML += `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h4 style="margin-top: 0;">Social Media Usernames (Optional)</h4>
                    <div id="new-usernames-list">
                        <!-- Usernames will be added here -->
                    </div>
                    <div class="form-grid-2" style="margin-top: 10px;">
                        <div class="form-group">
                            <label>Platform</label>
                            <select id="create-actor-username-platform">
                                <option value="">Select platform...</option>
                                <option value="twitter">Twitter/X</option>
                                <option value="instagram">Instagram</option>
                                <option value="tiktok">TikTok</option>
                                <option value="youtube">YouTube</option>
                                <option value="telegram">Telegram</option>
                                <option value="facebook">Facebook</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Username</label>
                            <div style="display: flex; gap: 10px;">
                                <input type="text" id="create-actor-username-input" placeholder="username" style="flex: 1;" 
                                       onkeypress="if(event.key === 'Enter') { event.preventDefault(); addNewActorUsername(); }">
                                <button type="button" class="btn btn-secondary" onclick="addNewActorUsername()" style="padding: 8px 16px;">Add</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            if (type === 'person') {
                formHTML += `
                    <div class="form-group">
                        <label>Full Name *</label>
                        <input type="text" id="new-full_name" required>
                    </div>
                    <div class="form-group">
                        <label>Present Role</label>
                        <input type="text" id="new-present_role">
                    </div>
                    <div class="form-group">
                        <label>Role Category</label>
                        <input type="text" id="new-role_category" list="new-role_categories" placeholder="Type or select existing category...">
                        <datalist id="new-role_categories">
                            ${existingRoleCategories.map(category => 
                                `<option value="${category}">`
                            ).join('')}
                        </datalist>
                    </div>
                    <div class="form-grid-2">
                        <div class="form-group">
                            <label>City</label>
                            <input type="text" id="new-city">
                        </div>
                        <div class="form-group">
                            <label>State</label>
                            <input type="text" id="new-state" placeholder="e.g., Arizona, California">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>About</label>
                        <textarea id="new-about"></textarea>
                    </div>
                    <div class="form-grid-2">
                        <div class="form-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="new-is_tpusa_staff">
                                TPUSA Staff
                            </label>
                        </div>
                        <div class="form-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="new-is_tpusa_affiliated">
                                TPUSA Affiliated
                            </label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Primary Organization (Optional)</label>
                        <select id="new-primary_organization_id">
                            <option value="">Select organization...</option>
                            ${organizations.map(org => 
                                `<option value="${org.id}">${org.name}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
                
                // Add actor linking section for new person
                formHTML += `
                    <div class="actor-link-section">
                        <label class="checkbox-label">
                            <input type="checkbox" id="new-enable-actor-links" onchange="toggleNewActorLinking()">
                            <strong>Link this person to other actors</strong>
                        </label>
                        
                        <div id="new-actor-linking-section" style="display: none; margin-top: 15px;">
                            <div class="form-group">
                                <label>Search for actors to link</label>
                                <input type="text" id="new-link-search" placeholder="Search actors..." onkeyup="debouncedSearchNewLinks()">
                            </div>
                            <div id="new-link-results" style="max-height: 150px; overflow-y: auto; margin: 10px 0;"></div>
                            <div id="new-linked-actors" class="linked-actors-list">
                                <!-- Selected actors will appear here -->
                            </div>
                        </div>
                    </div>
                `;
            } else if (type === 'organization') {
                // Get all field mappings for organization type
                const actorTypeId = await getActorTypeId('organization');
                const fieldMappings = actorTypeId ? await getFieldMappings(actorTypeId) : [];
                
                // Start with required fields
                formHTML += `
                    <div class="form-group">
                        <label>Organization Name *</label>
                        <input type="text" id="new-name" required>
                    </div>
                    <div class="form-grid-2">
                        <div class="form-group">
                            <label>City</label>
                            <input type="text" id="new-org-city" placeholder="e.g., Phoenix, Washington">
                        </div>
                        <div class="form-group">
                            <label>State</label>
                            <input type="text" id="new-org-state" placeholder="e.g., Arizona, DC">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>About / Summary</label>
                        <textarea id="new-summary_focus" placeholder="Organization description or focus areas"></textarea>
                    </div>
                `;
                
                // Add all mapped fields dynamically
                for (const mapping of fieldMappings) {
                    const fieldId = `new-org-field-${mapping.column_name}`;
                    const existingValues = await getExistingValues('organization', mapping.column_name);
                    const datalistId = `${fieldId}-list`;
                    
                    // Skip if this is a standard field we already added
                    if (['name', 'city', 'state', 'about'].includes(mapping.column_name)) {
                        continue;
                    }
                    
                    // Determine input type based on column type
                    if (mapping.column_name.startsWith('custom_bool')) {
                        formHTML += `
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="${fieldId}">
                                    ${mapping.field_name}
                                </label>
                            </div>
                        `;
                    } else if (mapping.column_name.startsWith('custom_date')) {
                        formHTML += `
                            <div class="form-group">
                                <label>${mapping.field_name}</label>
                                <input type="date" id="${fieldId}">
                            </div>
                        `;
                    } else if (mapping.column_name.startsWith('custom_numeric')) {
                        formHTML += `
                            <div class="form-group">
                                <label>${mapping.field_name}</label>
                                <input type="number" id="${fieldId}" step="any">
                            </div>
                        `;
                    } else {
                        // Text field with autocomplete
                        formHTML += `
                            <div class="form-group">
                                <label>${mapping.field_name}</label>
                                <input type="text" id="${fieldId}" list="${datalistId}">
                                <datalist id="${datalistId}">
                                    ${existingValues.map(v => `<option value="${v}">`).join('')}
                                </datalist>
                            </div>
                        `;
                    }
                }
                
                // Add backward compatibility fields that might not be in mappings
                if (!fieldMappings.find(m => m.field_name === 'Region')) {
                    formHTML += `
                        <div class="form-group">
                            <label>Region</label>
                            <input type="text" id="new-region_scope" placeholder="e.g., Southwest, National, Northeast">
                        </div>
                    `;
                }
                
                if (!fieldMappings.find(m => m.field_name === 'Type')) {
                    formHTML += `
                        <div class="form-group">
                            <label>Organization Type</label>
                            <select id="new-type">
                                <option value="external">External</option>
                                <option value="tpusa">TPUSA</option>
                                <option value="affiliate">Affiliate</option>
                            </select>
                        </div>
                    `;
                }
                
                if (!fieldMappings.find(m => m.field_name === 'Is TPUSA')) {
                    formHTML += `
                        <div class="form-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="new-is_tpusa">
                                Is TPUSA Organization
                            </label>
                        </div>
                    `;
                }
                
                // Add actor linking section for new organization
                formHTML += `
                    <div class="actor-link-section">
                        <label class="checkbox-label">
                            <input type="checkbox" id="new-enable-actor-links" onchange="toggleNewActorLinking()">
                            <strong>Link this organization to other actors</strong>
                        </label>
                        
                        <div id="new-actor-linking-section" style="display: none; margin-top: 15px;">
                            <div class="form-group">
                                <label>Search for actors to link</label>
                                <input type="text" id="new-link-search" placeholder="Search actors..." onkeyup="debouncedSearchNewLinks()">
                            </div>
                            <div id="new-link-results" style="max-height: 150px; overflow-y: auto; margin: 10px 0;"></div>
                            <div id="new-linked-actors" class="linked-actors-list">
                                <!-- Selected actors will appear here -->
                            </div>
                        </div>
                    </div>
                `;
            } else if (type === 'chapter') {
                formHTML += `
                    <div class="form-group">
                        <label>Chapter Name *</label>
                        <input type="text" id="new-name" required>
                    </div>
                    <div class="form-group">
                        <label>School Type</label>
                        <select id="new-school_type">
                            <option value="college">College</option>
                            <option value="high_school">High School</option>
                        </select>
                    </div>
                    <div class="form-grid-2">
                        <div class="form-group">
                            <label>City</label>
                            <input type="text" id="new-city">
                        </div>
                        <div class="form-group">
                            <label>State Code</label>
                            <input type="text" id="new-state_code" placeholder="e.g., AZ, CA, TX" maxlength="2">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="new-active" checked>
                            Active Chapter
                        </label>
                    </div>
                `;
                
                // Add actor linking section for new chapter
                formHTML += `
                    <div class="actor-link-section">
                        <label class="checkbox-label">
                            <input type="checkbox" id="new-enable-actor-links" onchange="toggleNewActorLinking()">
                            <strong>Link this chapter to other actors</strong>
                        </label>
                        
                        <div id="new-actor-linking-section" style="display: none; margin-top: 15px;">
                            <div class="form-group">
                                <label>Search for actors to link</label>
                                <input type="text" id="new-link-search" placeholder="Search actors..." onkeyup="debouncedSearchNewLinks()">
                            </div>
                            <div id="new-link-results" style="max-height: 150px; overflow-y: auto; margin: 10px 0;"></div>
                            <div id="new-linked-actors" class="linked-actors-list">
                                <!-- Selected actors will appear here -->
                            </div>
                        </div>
                    </div>
                `;
            }

            formHTML += `
                <div class="form-actions">
                    <button class="btn btn-secondary" onclick="closeModal('create-actor-modal')">Cancel</button>
                    <button class="btn btn-primary" onclick="createNewActor()">
                        Create ${type.charAt(0).toUpperCase() + type.slice(1)}
                    </button>
                </div>
            `;

            document.getElementById('create-actor-form').innerHTML = formHTML;
            document.getElementById('create-actor-form').style.display = 'block';
            
            // Initialize the usernames display
            updateNewUsernamesDisplay();
        }

        async function createNewActor() {
            const type = selectedActorType;
            
            try {
                // Build fields object based on actor type
                let fields = {};
                let name, city, state;
                
                if (type === 'person') {
                    name = document.getElementById('new-full_name').value;
                    if (!name) {
                        alert('Name is required');
                        return;
                    }
                    
                    city = document.getElementById('new-city').value || null;
                    state = document.getElementById('new-state').value || null;
                    
                    fields = {
                        present_role: document.getElementById('new-present_role').value || null,
                        role_category: document.getElementById('new-role_category').value || null,
                        primary_organization_id: document.getElementById('new-primary_organization_id').value || null,
                        about: document.getElementById('new-about').value || null,
                        is_tpusa_staff: document.getElementById('new-is_tpusa_staff').checked,
                        is_tpusa_affiliated: document.getElementById('new-is_tpusa_affiliated').checked
                    };
                } else if (type === 'organization') {
                    name = document.getElementById('new-name').value;
                    if (!name) {
                        alert('Name is required');
                        return;
                    }
                    
                    // Get city and state (standard fields)
                    city = document.getElementById('new-org-city').value || null;
                    state = document.getElementById('new-org-state').value || null;
                    
                    // Get about field
                    const aboutText = document.getElementById('new-summary_focus').value || null;
                    
                    // Build fields object from all dynamic fields
                    fields = {
                        about: aboutText  // Use standard 'about' field for summary
                    };
                    
                    // Get field mappings to collect all dynamic field values
                    const actorTypeId = await getActorTypeId('organization');
                    if (actorTypeId) {
                        const fieldMappings = await getFieldMappings(actorTypeId);
                        
                        for (const mapping of fieldMappings) {
                            // Skip standard fields
                            if (['name', 'city', 'state', 'about'].includes(mapping.column_name)) {
                                continue;
                            }
                            
                            const fieldId = `new-org-field-${mapping.column_name}`;
                            const element = document.getElementById(fieldId);
                            
                            if (element) {
                                if (mapping.column_name.startsWith('custom_bool')) {
                                    fields[mapping.field_name] = element.checked;
                                } else if (mapping.column_name.startsWith('custom_numeric')) {
                                    const value = element.value ? parseFloat(element.value) : null;
                                    if (value !== null) fields[mapping.field_name] = value;
                                } else if (element.value) {
                                    fields[mapping.field_name] = element.value;
                                }
                            }
                        }
                    }
                    
                    // Add backward compatibility fields
                    const regionElement = document.getElementById('new-region_scope');
                    if (regionElement && regionElement.value) {
                        fields.region = regionElement.value;
                    }
                    
                    const typeElement = document.getElementById('new-type');
                    if (typeElement && typeElement.value) {
                        fields.type = typeElement.value;
                    }
                    
                    const tpusaElement = document.getElementById('new-is_tpusa');
                    if (tpusaElement) {
                        fields.is_tpusa = tpusaElement.checked;
                    }
                } else if (type === 'chapter') {
                    name = document.getElementById('new-name').value;
                    if (!name) {
                        alert('Name is required');
                        return;
                    }
                    
                    city = document.getElementById('new-city').value || null;
                    state = document.getElementById('new-state_code').value || null;
                    
                    fields = {
                        school_type: document.getElementById('new-school_type').value,
                        state_code: state,
                        active: document.getElementById('new-active').checked
                    };
                }
                
                // Get first username for backward compatibility
                const firstUsername = newActorUsernames.length > 0 ? newActorUsernames[0].username : null;
                const firstPlatform = newActorUsernames.length > 0 ? newActorUsernames[0].platform : null;
                
                // Call V2 creation function with first username
                const result = await callSupabaseFunction('create_v2_actor_manual', {
                    p_actor_type: type,
                    p_name: name,
                    p_city: city,
                    p_state: state,
                    p_fields: fields,
                    p_username: firstUsername,
                    p_platform: firstPlatform
                });
                
                const newActorId = result;
                
                // Add additional usernames if there are more than one
                if (newActorUsernames.length > 1) {
                    for (let i = 1; i < newActorUsernames.length; i++) {
                        const { platform, username } = newActorUsernames[i];
                        try {
                            await supabaseRequest('v2_actor_usernames', {
                                method: 'POST',
                                body: JSON.stringify({
                                    actor_id: newActorId,
                                    actor_type: type,
                                    platform: platform,
                                    username: username,
                                    verified: false,
                                    created_at: new Date().toISOString(),
                                    updated_at: new Date().toISOString()
                                })
                            });
                            console.log(`Successfully added ${platform} username: ${username}`);
                        } catch (err) {
                            console.error(`Failed to add username ${username} on ${platform}:`, err);
                            alert(`Warning: Failed to add ${platform} username ${username}. You may need to add it manually.`);
                        }
                    }
                }
                
                // Add actor links if any were selected
                if (document.getElementById('new-enable-actor-links') && document.getElementById('new-enable-actor-links').checked) {
                    if (selectedLinkedActors.length > 0) {
                        for (let i = 0; i < selectedLinkedActors.length; i++) {
                            const linkedActor = selectedLinkedActors[i];
                            const relType = document.getElementById(`new-rel-${i}`).value;
                            
                            if (!relType) {
                                console.warn(`Skipping link to ${linkedActor.name} - no relationship type selected`);
                                continue;
                            }
                            
                            // Collect metadata fields
                            const metadata = {};
                            const metadataDiv = document.getElementById(`new-metadata-${i}`);
                            const metadataFields = metadataDiv.querySelectorAll('.metadata-field');
                            
                            metadataFields.forEach((field, j) => {
                                const key = field.querySelector(`#new-meta-key-${i}-${j}`).value;
                                const value = field.querySelector(`#new-meta-value-${i}-${j}`).value;
                                if (key && value) {
                                    metadata[key] = value;
                                }
                            });
                            
                            try {
                                await supabaseRequest('v2_actor_links', {
                                    method: 'POST',
                                    body: JSON.stringify({
                                        from_actor_id: newActorId,
                                        to_actor_id: linkedActor.id,
                                        relationship: relType,
                                        role: document.getElementById(`new-role-${i}`).value || null,
                                        role_category: document.getElementById(`new-role-cat-${i}`).value || null,
                                        is_primary: document.getElementById(`new-primary-${i}`).checked,
                                        start_date: document.getElementById(`new-start-${i}`).value || null,
                                        end_date: document.getElementById(`new-end-${i}`).value || null,
                                        metadata: Object.keys(metadata).length > 0 ? metadata : {},
                                        created_at: new Date().toISOString()
                                    })
                                });
                            } catch (linkError) {
                                console.error('Error creating actor link:', linkError);
                            }
                        }
                    }
                }
                
                // Clear selected linked actors
                selectedLinkedActors = [];
                
                document.getElementById('create-success-message').innerHTML = 
                    '<div class="success-message">Successfully created new actor with links!</div>';
                document.getElementById('create-success-message').style.display = 'block';
                
                // Refresh and close
                setTimeout(() => {
                    closeModal('create-actor-modal');
                    if (document.getElementById('existing-tab').classList.contains('active')) {
                        loadExistingActorsMain();
                    }
                }, 2000);

            } catch (error) {
                console.error('Error creating actor:', error);
                document.getElementById('create-success-message').innerHTML = 
                    '<div class="error-message">Error creating actor: ' + error.message + '</div>';
                document.getElementById('create-success-message').style.display = 'block';
            }
        }

        // Edit Actor Modal Functions
        function openEditActorModal() {
            selectedActorForEdit = null;
            document.getElementById('edit-actor-search').value = '';
            document.getElementById('actor-edit-section').style.display = 'none';
            document.getElementById('edit-actor-modal').style.display = 'block';
            
            loadActorsForEdit();
        }
        
        let currentEditActorsPage = 0;
        const editActorsPageSize = 50;
        let hasMoreEditActors = true;
        let loadedEditActors = [];
        
        async function loadActorsForEdit(isLoadMore = false) {
            try {
                if (!isLoadMore) {
                    currentEditActorsPage = 0;
                    loadedEditActors = [];
                    hasMoreEditActors = true;
                    document.getElementById('edit-actors-list').innerHTML = '<div class="loading">Loading actors...</div>';
                }
                
                const offset = currentEditActorsPage * editActorsPageSize;
                
                // Include primary relationships in the query
                const actors = await supabaseRequest(`v2_actors?select=*,primary_relationships:v2_actor_links!actor_links_from_actor_id_fkey(relationship,role,is_primary,to_actor:v2_actors!actor_links_to_actor_id_fkey(id,name,actor_type))&order=name&limit=${editActorsPageSize}&offset=${offset}`);
                
                // Check if we have more data
                if (actors.length < editActorsPageSize) {
                    hasMoreEditActors = false;
                }
                
                // Filter to only keep primary relationships
                actors.forEach(actor => {
                    if (actor.primary_relationships) {
                        actor.primary_relationship = actor.primary_relationships.find(rel => rel.is_primary === true) || actor.primary_relationships[0];
                        delete actor.primary_relationships;
                    }
                });
                
                if (isLoadMore) {
                    loadedEditActors = [...loadedEditActors, ...actors];
                    currentEditActorsPage++;
                } else {
                    loadedEditActors = actors;
                }
                
                displayActorsForEdit(loadedEditActors, hasMoreEditActors);
                
            } catch (error) {
                console.error('Error loading actors:', error);
                document.getElementById('edit-actors-list').innerHTML = 
                    '<div class="error-message">Error loading actors</div>';
            }
        }
        
        function displayActorsForEdit(actors, showLoadMore = false) {
            if (actors.length === 0) {
                document.getElementById('edit-actors-list').innerHTML = 
                    '<div class="no-results">No actors found</div>';
                return;
            }

            let tableHTML = `
                <table class="existing-actors-table" style="width: 100%; font-size: 14px;">
                    <thead>
                        <tr>
                            <th style="width: 10%;">Type</th>
                            <th style="width: 25%;">Name</th>
                            <th style="width: 10%;">State</th>
                            <th style="width: 25%;">Primary Organization</th>
                            <th style="width: 15%;">Role</th>
                            <th style="width: 15%;">Action</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            actors.forEach(actor => {
                const escapedName = actor.name.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                
                // Get primary organization info
                let primaryOrg = 'N/A';
                let role = 'N/A';
                if (actor.primary_relationship && actor.primary_relationship.to_actor) {
                    primaryOrg = actor.primary_relationship.to_actor.name;
                    role = actor.primary_relationship.role || actor.primary_relationship.relationship || 'N/A';
                }
                
                // Get state
                const state = actor.state || 'N/A';
                
                // Add type-specific styling
                let typeClass = '';
                if (actor.actor_type === 'person') typeClass = 'type-person';
                else if (actor.actor_type === 'organization') typeClass = 'type-organization';
                else if (actor.actor_type === 'chapter') typeClass = 'type-chapter';
                
                tableHTML += `
                    <tr class="${typeClass}">
                        <td><span style="padding: 2px 8px; background: #e3f2fd; border-radius: 4px; font-size: 12px;">${actor.actor_type}</span></td>
                        <td><strong>${actor.name}</strong></td>
                        <td>${state}</td>
                        <td style="color: #666; font-size: 13px;">${primaryOrg}</td>
                        <td style="color: #666; font-size: 13px;">${role}</td>
                        <td>
                            <button class="btn btn-primary" data-actor-id="${actor.id}" data-actor-name="${escapedName}" onclick="selectActorForEdit(this.getAttribute('data-actor-id'), this.getAttribute('data-actor-name'))" style="padding: 6px 12px; font-size: 13px;">Edit</button>
                        </td>
                    </tr>
                `;
            });

            tableHTML += '</tbody></table>';
            
            // Add Load More button if there are more actors
            if (showLoadMore) {
                tableHTML += `
                    <div style="text-align: center; margin: 20px 0;">
                        <button class="btn btn-primary" onclick="loadActorsForEdit(true)" style="padding: 10px 20px; font-size: 14px;">
                            Load More Actors
                        </button>
                    </div>
                `;
            }
            
            document.getElementById('edit-actors-list').innerHTML = tableHTML;
        }
        
        async function selectActorForEdit(actorId, actorName) {
            console.log('selectActorForEdit called with:', actorId, actorName);
            try {
                // Load complete actor data using the optimized SQL function
                const actorData = await callSupabaseFunction('get_actor_complete_data', {
                    actor_id_param: actorId
                });
                console.log('Complete actor data loaded:', actorData);
                
                if (!actorData || actorData.length === 0) {
                    throw new Error('Actor not found');
                }
                
                selectedActorForEdit = actorData[0];
                
                // Debug logging to understand data structure
                console.log('🔍 Actor data structure check:');
                console.log('  - Has metadata_fields?', !!selectedActorForEdit.metadata_fields);
                console.log('  - metadata_fields:', selectedActorForEdit.metadata_fields);
                console.log('  - Has relationships?', !!selectedActorForEdit.relationships);
                console.log('  - relationships:', selectedActorForEdit.relationships);
                console.log('  - Has field_schema?', !!selectedActorForEdit.field_schema);
                console.log('  - Has indexed_fields?', !!selectedActorForEdit.indexed_fields);
                
                selectedActorForUsername = { 
                    id: actorId, 
                    name: actorName || selectedActorForEdit.name, 
                    actor_type: selectedActorForEdit.actor_type  // Changed from 'type' to 'actor_type'
                };
                
                document.getElementById('selected-edit-actor-name').textContent = actorName || selectedActorForEdit.name;
                document.getElementById('actor-edit-section').style.display = 'block';
                
                // Reset tabs - pass null for event since we're calling directly
                switchEditTab('details', null);
                
                // Load actor details
                await loadActorDetailsForEdit();
                
            } catch (error) {
                console.error('Error selecting actor for edit:', error);
                alert('Error loading actor details: ' + error.message);
            }
        }
        
        async function loadActorDetailsForEdit() {
            const actor = selectedActorForEdit;
            if (!actor) return;
            
            // Load field mappings for this actor type
            await loadFieldMappings();
            
            let formHTML = '';
            
            // Add prominent Edit/Save buttons at the top
            formHTML += `
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <button id="main-edit-toggle" class="btn btn-primary" onclick="toggleEditMode('details')" style="padding: 10px 20px; font-size: 16px;">
                            Edit Actor Details
                        </button>
                    </div>
                    <div id="main-save-section" style="display: none; gap: 10px;">
                        <button class="btn btn-secondary" onclick="cancelEditMode('details')" style="padding: 10px 20px; font-size: 16px;">
                            Cancel
                        </button>
                        <button class="btn btn-success" onclick="saveActorDetails()" style="padding: 10px 20px; font-size: 16px; background: #28a745;">
                            Save Changes
                        </button>
                    </div>
                </div>
            `;
            
            // Section 1: Basic Information (standard fields)
            formHTML += '<h4 style="margin-top: 0; color: #4facfe;">Basic Information</h4>';
            formHTML += '<div class="form-grid-2">';
            formHTML += `
                <div class="form-group">
                    <label>ID (Read-only)</label>
                    <input type="text" value="${actor.id}" readonly style="background: #e9ecef;">
                </div>
                <div class="form-group">
                    <label>Actor Type</label>
                    <input type="text" value="${actor.actor_type}" readonly style="background: #e9ecef;">
                </div>
                <div class="form-group">
                    <label>Name *</label>
                    <input type="text" id="edit-name" value="${actor.name || ''}" readonly style="background: #f5f5f5;">
                </div>
                <div class="form-group">
                    <label>City</label>
                    <input type="text" id="edit-city" value="${actor.city || ''}" readonly style="background: #f5f5f5;">
                </div>
                <div class="form-group">
                    <label>State</label>
                    <input type="text" id="edit-state" value="${actor.state || ''}" readonly style="background: #f5f5f5;">
                </div>
                <div class="form-group">
                    <label>Region</label>
                    <input type="text" id="edit-region" value="${actor.region || ''}" readonly style="background: #f5f5f5;">
                </div>
            `;
            formHTML += '</div>';
            
            // About field (full width)
            formHTML += `
                <div class="form-group">
                    <label>About</label>
                    <textarea id="edit-about" rows="3" readonly style="background: #f5f5f5;">${actor.about || ''}</textarea>
                </div>
            `;
            
            // Should scrape checkbox
            formHTML += `
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="edit-should_scrape" ${actor.should_scrape ? 'checked' : ''} disabled>
                        Should Scrape
                    </label>
                </div>
            `;
            
            // Section 2: Indexed Fields (custom columns with fast search)
            formHTML += '<h4 style="margin-top: 30px; color: #4facfe;">Indexed Fields (Fast Search Enabled)</h4>';
            formHTML += '<p style="color: #666; font-size: 14px; margin-bottom: 15px;">These fields are stored in dedicated columns for fast searching and filtering.</p>';
            formHTML += '<div class="indexed-fields-container">';
            
            // Build indexed fields dynamically based on field mappings
            if (selectedFieldMappings && selectedFieldMappings.indexed) {
                Object.entries(selectedFieldMappings.indexed).forEach(([fieldName, mapping]) => {
                    const columnName = mapping.column;
                    const dataType = mapping.type;
                    const value = actor[columnName] || '';
                    const label = formatFieldLabel(fieldName);
                    
                    formHTML += `
                        <div class="field-item" style="background: #f8f9fa; padding: 15px; margin-bottom: 10px; border-radius: 8px;">
                            <div class="field-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <label style="font-weight: 600; color: #333;">${label}</label>
                                <div class="field-actions" style="display: flex; gap: 5px;">
                                    <button class="field-action-btn demote-btn" style="padding: 4px 8px; font-size: 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;" 
                                            onclick="demoteToMetadata('${fieldName}', '${columnName}')">
                                        ↓ Move to Metadata
                                    </button>
                                    <small style="color: #6c757d;">Column: ${columnName}</small>
                                </div>
                            </div>
                    `;
                    
                    if (dataType === 'boolean' || dataType === 'bool') {
                        formHTML += `
                            <label class="checkbox-label">
                                <input type="checkbox" id="edit-${columnName}" data-field="${fieldName}" ${value ? 'checked' : ''}>
                                <span>${label}</span>
                            </label>
                        `;
                    } else if (dataType === 'numeric') {
                        formHTML += `
                            <input type="number" id="edit-${columnName}" data-field="${fieldName}" value="${value}" style="width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 4px;">
                        `;
                    } else if (dataType === 'date') {
                        formHTML += `
                            <input type="date" id="edit-${columnName}" data-field="${fieldName}" value="${value}" style="width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 4px;">
                        `;
                    } else {
                        formHTML += `
                            <input type="text" id="edit-${columnName}" data-field="${fieldName}" value="${value}" style="width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 4px;">
                        `;
                    }
                    
                    formHTML += `</div>`;
                });
            } else {
                // Fallback to hardcoded mappings if no field mappings loaded
                formHTML += getDefaultIndexedFields(actor);
            }
            
            formHTML += '</div>';
            
            // Section 3: Metadata Fields (stored in JSONB)
            formHTML += '<h4 style="margin-top: 30px; color: #4facfe;">Metadata Fields (Additional Info)</h4>';
            formHTML += '<p style="color: #666; font-size: 14px; margin-bottom: 15px;">These fields are stored in the JSONB data column. They can be promoted to indexed fields for faster searching.</p>';
            formHTML += '<div class="metadata-fields-container" id="metadata-fields-container">';
            // Metadata fields will be loaded by loadMetadataFieldsForEdit()
            formHTML += '</div>';
            
            document.getElementById('actor-details-form').innerHTML = formHTML;
            
            // Load metadata fields separately
            loadMetadataFieldsForEdit();
            
            // Load usernames
            await loadActorUsernames(actor.id);
            
            // Load actor relationships - use the data from get_actor_complete_data if available
            console.log('🔗 Loading relationships:');
            console.log('  - Actor has relationships?', !!actor.relationships);
            console.log('  - Relationships data:', actor.relationships);
            
            if (actor.relationships) {
                console.log('  ✅ Using relationships from SQL function');
                displayActorRelationshipsFromData(actor.relationships);
            } else {
                console.log('  ⚠️ No relationships in actor data, falling back to direct query');
                await loadActorRelationships(actor.id);
            }
        }
        
        // Helper function to format field names
        function formatFieldLabel(fieldName) {
            return fieldName
                .replace(/_/g, ' ')
                .replace(/\b\w/g, l => l.toUpperCase());
        }
        
        // Load indexed fields using the new data structure
        function getDefaultIndexedFields(actor) {
            let html = '';
            
            // Use indexed_fields and field_schema from get_actor_complete_data if available
            if (actor.indexed_fields && actor.field_schema) {
                Object.entries(actor.indexed_fields).forEach(([fieldName, value]) => {
                    const schema = actor.field_schema[fieldName];
                    if (schema) {
                        const label = formatFieldLabel(fieldName);
                        
                        if (schema.type === 'boolean') {
                            html += `
                                <div class="form-group">
                                    <label class="checkbox-label">
                                        <input type="checkbox" id="edit-${schema.column}" data-field="${fieldName}" ${value === 'true' || value === true ? 'checked' : ''} disabled>
                                        ${label}
                                    </label>
                                    <button type="button" class="demote-btn" onclick="demoteToMetadata('${fieldName}', '${schema.column}')" style="display: none;">Demote to Metadata</button>
                                </div>
                            `;
                        } else if (schema.type === 'numeric') {
                            html += `
                                <div class="form-group">
                                    <label>${label}</label>
                                    <input type="number" id="edit-${schema.column}" data-field="${fieldName}" value="${value || ''}" readonly style="background: #f5f5f5;">
                                    <button type="button" class="demote-btn" onclick="demoteToMetadata('${fieldName}', '${schema.column}')" style="display: none;">Demote to Metadata</button>
                                </div>
                            `;
                        } else if (schema.type === 'date') {
                            // Extract just the date part from datetime strings
                            let dateValue = value || '';
                            if (dateValue && dateValue.includes('T')) {
                                dateValue = dateValue.split('T')[0];
                            }
                            html += `
                                <div class="form-group">
                                    <label>${label}</label>
                                    <input type="date" id="edit-${schema.column}" data-field="${fieldName}" value="${dateValue}" readonly style="background: #f5f5f5;">
                                    <button type="button" class="demote-btn" onclick="demoteToMetadata('${fieldName}', '${schema.column}')" style="display: none;">Demote to Metadata</button>
                                </div>
                            `;
                        } else {
                            html += `
                                <div class="form-group">
                                    <label>${label}</label>
                                    <input type="text" id="edit-${schema.column}" data-field="${fieldName}" value="${value || ''}" readonly style="background: #f5f5f5;">
                                    <button type="button" class="demote-btn" onclick="demoteToMetadata('${fieldName}', '${schema.column}')" style="display: none;">Demote to Metadata</button>
                                </div>
                            `;
                        }
                    }
                });
            } else if (actor.actor_type === 'person') {
                // Fallback to default mappings
                html += `
                    <div class="form-group">
                        <label>Present Role</label>
                        <input type="text" id="edit-custom_text_1" data-field="present_role" value="${actor.custom_text_1 || ''}">
                    </div>
                    <div class="form-group">
                        <label>Role Category</label>
                        <input type="text" id="edit-custom_text_2" data-field="role_category" value="${actor.custom_text_2 || ''}">
                    </div>
                    <div class="form-group">
                        <label>Division</label>
                        <input type="text" id="edit-custom_text_3" data-field="division" value="${actor.custom_text_3 || ''}">
                    </div>
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="edit-custom_bool_1" data-field="is_tpusa_staff" ${actor.custom_bool_1 ? 'checked' : ''}>
                            Is TPUSA Staff
                        </label>
                    </div>
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="edit-custom_bool_2" data-field="is_tpusa_affiliated" ${actor.custom_bool_2 ? 'checked' : ''}>
                            Is TPUSA Affiliated
                        </label>
                    </div>
                `;
            } else if (actor.actor_type === 'organization') {
                html += `
                    <div class="form-group">
                        <label>Organization Type</label>
                        <input type="text" id="edit-custom_text_1" data-field="type" value="${actor.custom_text_1 || ''}">
                    </div>
                    <div class="form-group">
                        <label>Parent Organization</label>
                        <input type="text" id="edit-custom_text_2" data-field="parent_organization" value="${actor.custom_text_2 || ''}">
                    </div>
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="edit-custom_bool_1" data-field="is_tpusa" ${actor.custom_bool_1 ? 'checked' : ''}>
                            Is TPUSA Organization
                        </label>
                    </div>
                `;
            } else if (actor.actor_type === 'chapter') {
                html += `
                    <div class="form-group">
                        <label>School Type</label>
                        <input type="text" id="edit-custom_text_1" data-field="school_type" value="${actor.custom_text_1 || ''}">
                    </div>
                    <div class="form-group">
                        <label>State Code</label>
                        <input type="text" id="edit-custom_text_2" data-field="state_code" value="${actor.custom_text_2 || ''}" maxlength="2">
                    </div>
                    <div class="form-group">
                        <label>Active Members</label>
                        <input type="number" id="edit-custom_numeric_1" data-field="active_members" value="${actor.custom_numeric_1 || ''}">
                    </div>
                `;
            }
            
            return html;
        }
        
        // Load field mappings for the current actor type
        let selectedFieldMappings = null;
        
        async function loadFieldMappings() {
            if (!selectedActorForEdit) return;
            
            try {
                // Try to load field mappings from the API
                const mappingsQuery = `v2_actor_type_field_mappings?select=field_name,column_name,data_type,is_indexed&actor_type_id=eq.${selectedActorForEdit.actor_type_id}`;
                const mappings = await supabaseRequest(mappingsQuery).catch(() => []);
                
                if (mappings && mappings.length > 0) {
                    selectedFieldMappings = {
                        indexed: {},
                        metadata: {}
                    };
                    
                    mappings.forEach(mapping => {
                        const fieldInfo = {
                            column: mapping.column_name,
                            type: mapping.data_type,
                            indexed: mapping.is_indexed
                        };
                        
                        if (mapping.is_indexed) {
                            selectedFieldMappings.indexed[mapping.field_name] = fieldInfo;
                        } else {
                            selectedFieldMappings.metadata[mapping.field_name] = fieldInfo;
                        }
                    });
                }
            } catch (error) {
                console.log('Field mappings not available, using defaults');
            }
        }
        
        function loadMetadataFieldsForEdit() {
            const actor = selectedActorForEdit;
            if (!actor) return;
            
            console.log('📝 Loading metadata fields:');
            console.log('  - Actor has metadata_fields?', !!actor.metadata_fields);
            console.log('  - metadata_fields content:', actor.metadata_fields);
            console.log('  - Actor has data field?', !!actor.data);
            console.log('  - data field content:', actor.data);
            
            let metadataHTML = '';
            
            // Use the metadata_fields from get_actor_complete_data if available
            if (actor.metadata_fields) {
                console.log('  ✅ Using metadata_fields from SQL function');
                Object.entries(actor.metadata_fields).forEach(([key, value]) => {
                    const label = formatFieldLabel(key);
                    const fieldType = inferFieldType(value);
                    metadataHTML += createMetadataFieldHTML(key, label, value, fieldType);
                });
            } else {
                // Fallback to the old method if metadata_fields is not available
                const jsonData = actor.data || {};
                
                // Check for metadata field mappings first
                if (selectedFieldMappings && selectedFieldMappings.metadata) {
                    Object.entries(selectedFieldMappings.metadata).forEach(([fieldName, mapping]) => {
                        const value = jsonData[fieldName] || '';
                        const label = formatFieldLabel(fieldName);
                        
                        metadataHTML += createMetadataFieldHTML(fieldName, label, value, mapping.type);
                    });
                }
                
                // Add any additional fields in jsonData that aren't in mappings
                Object.entries(jsonData).forEach(([key, value]) => {
                    // Skip if this field is already mapped
                    if (selectedFieldMappings && 
                        (selectedFieldMappings.metadata[key] || selectedFieldMappings.indexed[key])) {
                        return;
                    }
                    
                    const label = formatFieldLabel(key);
                    const fieldType = inferFieldType(value);
                    metadataHTML += createMetadataFieldHTML(key, label, value, fieldType);
                });
            }
            
            if (!metadataHTML) {
                metadataHTML = '<p style="color: #666;">No metadata fields stored. Use the "Add New Field" button to add metadata.</p>';
            }
            
            // Add the "Add New Field" section
            metadataHTML += `
                <div id="add-metadata-field-section" style="display: none; margin-top: 15px; padding: 15px; background: #f0f7ff; border-radius: 8px;">
                    <h4>Add New Metadata Field</h4>
                    <div class="form-grid-2">
                        <div class="form-group">
                            <label>Field Name</label>
                            <input type="text" id="new-metadata-field-name" placeholder="e.g., notes, twitter_handle">
                        </div>
                        <div class="form-group">
                            <label>Field Type</label>
                            <select id="new-metadata-field-type">
                                <option value="text">Text</option>
                                <option value="textarea">Long Text</option>
                                <option value="numeric">Number</option>
                                <option value="boolean">True/False</option>
                                <option value="date">Date</option>
                            </select>
                        </div>
                        <div class="form-group" style="grid-column: 1 / -1;">
                            <label>Initial Value</label>
                            <input type="text" id="new-metadata-field-value" placeholder="Value">
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="addMetadataField()">Add Field</button>
                </div>
            `;
            
            document.getElementById('metadata-fields-container').innerHTML = metadataHTML;
        }
        
        function createMetadataFieldHTML(fieldName, label, value, fieldType) {
            let html = `
                <div class="field-item metadata-field-${fieldName}" style="background: #f0f7ff; padding: 15px; margin-bottom: 10px; border-radius: 8px;">
                    <div class="field-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <label style="font-weight: 600; color: #333;">${label}</label>
                        <div class="field-actions" style="display: flex; gap: 5px;">
                            <button class="field-action-btn promote-btn" style="padding: 4px 8px; font-size: 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;"
                                    onclick="promoteToIndexed('${fieldName}', '${fieldType}')">
                                ↑ Make Indexed
                            </button>
                            <button class="field-action-btn remove-btn" style="padding: 4px 8px; font-size: 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;"
                                    onclick="removeMetadataField('${fieldName}')">
                                Remove
                            </button>
                        </div>
                    </div>
            `;
            
            if (fieldType === 'boolean') {
                html += `
                    <label class="checkbox-label">
                        <input type="checkbox" id="metadata-${fieldName}" data-field="${fieldName}" ${value ? 'checked' : ''} disabled>
                        <span>${label}</span>
                    </label>
                `;
            } else if (fieldType === 'numeric') {
                html += `
                    <input type="number" id="metadata-${fieldName}" data-field="${fieldName}" value="${value || ''}" readonly style="width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5;">
                `;
            } else if (fieldType === 'date') {
                // Extract just the date part from datetime strings
                let dateValue = value || '';
                if (dateValue && dateValue.includes('T')) {
                    dateValue = dateValue.split('T')[0];
                }
                html += `
                    <input type="date" id="metadata-${fieldName}" data-field="${fieldName}" value="${dateValue}" readonly style="width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5;">
                `;
            } else if (fieldType === 'textarea' || (typeof value === 'string' && value.length > 100)) {
                html += `
                    <textarea id="metadata-${fieldName}" data-field="${fieldName}" rows="3" readonly style="width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5;">${value || ''}</textarea>
                `;
            } else {
                html += `
                    <input type="text" id="metadata-${fieldName}" data-field="${fieldName}" value="${value || ''}" readonly style="width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5;">
                `;
            }
            
            html += `</div>`;
            return html;
        }
        
        function inferFieldType(value) {
            if (typeof value === 'boolean') return 'boolean';
            if (typeof value === 'number') return 'numeric';
            if (typeof value === 'string' && value.match(/^\d{4}-\d{2}-\d{2}/)) return 'date';
            if (typeof value === 'string' && value.length > 100) return 'textarea';
            return 'text';
        }
        
        function loadJsonbDataForEdit() {
            const actor = selectedActorForEdit;
            if (!actor) return;
            
            // Hide this section since metadata is now handled in the metadata fields section
            const jsonbContainer = document.getElementById('actor-jsonb-data');
            if (jsonbContainer) {
                jsonbContainer.style.display = 'none';
                return;
            }
            
            // Legacy code - only used if metadata_fields is not available
            const jsonData = actor.data || {};
            
            let jsonbHTML = '<div class="form-grid-2">';
            
            // Skip if we're using the new metadata_fields structure
            if (actor.metadata_fields) {
                jsonbHTML += '<p style="color: #666; grid-column: 1 / -1;">Metadata is displayed in the Metadata Fields section above.</p>';
            } else {
                // Legacy display for old data structure
                const jsonbKeys = Object.keys(jsonData);
                
                if (jsonbKeys.length === 0) {
                    jsonbHTML += '<p style="color: #666; grid-column: 1 / -1;">No additional data stored.</p>';
                } else {
                    // For nested objects, flatten them
                    jsonbKeys.forEach(key => {
                        const value = jsonData[key];
                        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                            // Handle nested object
                            Object.keys(value).forEach(subKey => {
                                jsonbHTML += `
                                    <div class="form-group">
                                        <label>${key}.${subKey}</label>
                                        <input type="text" 
                                               id="jsonb-${key}-${subKey}" 
                                               data-path="${key}.${subKey}"
                                               value="${value[subKey] || ''}" 
                                               class="jsonb-field">
                                    </div>
                                `;
                            });
                        } else {
                            // Handle direct value
                            jsonbHTML += `
                                <div class="form-group">
                                    <label>${key}</label>
                                    <input type="text" 
                                           id="jsonb-${key}" 
                                           data-path="${key}"
                                           value="${value || ''}" 
                                           class="jsonb-field">
                                </div>
                            `;
                        }
                    });
                }
            }
            
            jsonbHTML += '</div>';
            
            // Add button to add new fields when in edit mode
            jsonbHTML += `
                <div id="add-jsonb-field-section" style="display: none; margin-top: 15px; padding: 15px; background: #f0f7ff; border-radius: 4px;">
                    <h4>Add New Field</h4>
                    <div class="form-grid-2">
                        <div class="form-group">
                            <label>Field Name</label>
                            <input type="text" id="new-jsonb-key" placeholder="e.g., notes or category.subcategory">
                        </div>
                        <div class="form-group">
                            <label>Field Value</label>
                            <input type="text" id="new-jsonb-value" placeholder="Value">
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="addJsonbField()">Add Field</button>
                </div>
            `;
            
            document.getElementById('jsonb-data-fields').innerHTML = jsonbHTML;
        }
        
        // Helper function to update actor
        async function updateActor(actorId, updateData) {
            return await supabaseRequest(`v2_actors?id=eq.${actorId}`, {
                method: 'PATCH',
                body: JSON.stringify(updateData)
            });
        }
        
        // Field promotion/demotion functions
        async function promoteToIndexed(fieldName, dataType) {
            if (!selectedActorForEdit) return;
            
            try {
                // Find next available custom column using the SQL function
                const columnResult = await callSupabaseFunction('get_next_available_custom_column', {
                    actor_id_param: selectedActorForEdit.id,
                    data_type_param: dataType
                });
                
                if (!columnResult) {
                    alert('No available indexed columns for this data type. Please demote an existing field first.');
                    return;
                }
                
                const columnName = columnResult;
                
                // Use the optimized SQL function for promotion
                await callSupabaseFunction('promote_field_to_indexed', {
                    actor_id_param: selectedActorForEdit.id,
                    field_name_param: fieldName,
                    column_name_param: columnName,
                    data_type_param: dataType
                });
                
                // Refresh the actor data and form
                await selectActorForEdit(selectedActorForEdit.id, selectedActorForEdit.name);
                alert(`Field "${fieldName}" promoted to indexed (column: ${columnName})`);
                
            } catch (error) {
                console.error('Error promoting field:', error);
                alert('Error promoting field: ' + error.message);
            }
        }
        
        async function demoteToMetadata(fieldName, columnName) {
            if (!selectedActorForEdit) return;
            
            try {
                // Use the optimized SQL function for demotion
                await callSupabaseFunction('demote_field_to_metadata', {
                    actor_id_param: selectedActorForEdit.id,
                    field_name_param: fieldName
                });
                
                // Refresh the actor data and form
                await selectActorForEdit(selectedActorForEdit.id, selectedActorForEdit.name);
                alert(`Field "${fieldName}" moved to metadata`);
                
            } catch (error) {
                console.error('Error demoting field:', error);
                alert('Error demoting field: ' + error.message);
            }
        }
        
        async function getNextAvailableColumn(dataType) {
            if (!selectedActorForEdit) return null;
            
            const typePrefix = dataType === 'numeric' ? 'custom_numeric_' :
                              dataType === 'date' ? 'custom_date_' :
                              dataType === 'boolean' ? 'custom_bool_' :
                              'custom_text_';
            
            const maxColumns = dataType === 'numeric' ? 5 :
                              dataType === 'date' ? 3 :
                              dataType === 'boolean' ? 2 :
                              10;
            
            // Check which columns are already in use
            for (let i = 1; i <= maxColumns; i++) {
                const columnName = typePrefix + i;
                if (!selectedActorForEdit[columnName]) {
                    return columnName;
                }
            }
            
            return null;
        }
        
        async function addMetadataField() {
            const fieldName = document.getElementById('new-metadata-field-name').value.trim();
            const fieldType = document.getElementById('new-metadata-field-type').value;
            const fieldValue = document.getElementById('new-metadata-field-value').value.trim();
            
            if (!fieldName) {
                alert('Please enter a field name');
                return;
            }

            if (!selectedActorForEdit) {
                alert('No actor selected for editing');
                return;
            }
            
            try {
                // Use the optimized SQL function to add metadata field
                await callSupabaseFunction('add_metadata_field', {
                    actor_id_param: selectedActorForEdit.id,
                    field_name_param: fieldName,
                    field_value_param: fieldValue,
                    data_type_param: fieldType
                });
                
                // Clear inputs
                document.getElementById('new-metadata-field-name').value = '';
                document.getElementById('new-metadata-field-value').value = '';
                document.getElementById('new-metadata-field-type').value = 'text';
                
                // Refresh the actor data and form
                await selectActorForEdit(selectedActorForEdit.id, selectedActorForEdit.name);
                alert(`Field "${fieldName}" added successfully`);
                
            } catch (error) {
                console.error('Error adding metadata field:', error);
                alert('Error adding field: ' + error.message);
            }
        }
        
        async function removeMetadataField(fieldName) {
            if (!confirm(`Are you sure you want to remove the field "${fieldName}"?`)) {
                return;
            }
            
            // Remove from UI
            const fieldElement = document.querySelector(`.metadata-field-${fieldName}`);
            if (fieldElement) {
                fieldElement.remove();
            }
            
            // The actual removal from database will happen when saving
        }
        
        function addJsonbField() {
            // Redirect to the new addMetadataField function
            addMetadataField();
        }
        
        function switchEditTab(tab, evt) {
            // Update tab buttons
            document.querySelectorAll('.edit-tab').forEach(t => t.classList.remove('active'));
            
            // Handle both direct calls and event calls
            if (evt && evt.target) {
                evt.target.classList.add('active');
            } else {
                // Find the correct tab button to highlight
                const tabIndex = tab === 'details' ? 0 : tab === 'usernames' ? 1 : 2;
                const tabButtons = document.querySelectorAll('.edit-tab');
                if (tabButtons[tabIndex]) {
                    tabButtons[tabIndex].classList.add('active');
                }
            }
            
            // Update tab content
            document.querySelectorAll('.edit-tab-content').forEach(c => c.classList.remove('active'));
            const tabContent = document.getElementById(`${tab}-tab`);
            if (tabContent) {
                tabContent.classList.add('active');
            }
        }
        
        function toggleEditMode(section) {
            editMode[section] = !editMode[section];
            
            const viewMode = document.getElementById(`${section}-view-mode`);
            const saveSection = document.getElementById(`${section}-save-section`);
            
            // Check if elements exist
            if (!viewMode || !saveSection) {
                console.error(`Elements not found for section: ${section}`);
                return;
            }
            
            // Find the toggle button - it might be inside or outside the viewMode
            let toggleBtn = viewMode.querySelector('.edit-mode-toggle');
            if (!toggleBtn && typeof event !== 'undefined' && event && event.target) {
                // Try to find it as a sibling or parent element
                toggleBtn = event.target;
            }
            
            if (editMode[section]) {
                viewMode.classList.remove('view-mode');
                saveSection.style.display = 'flex';
                if (toggleBtn) {
                    toggleBtn.textContent = 'Cancel Edit';
                    toggleBtn.classList.add('editing');
                }
                
                // Show the main save section and hide edit button
                const mainEditBtn = document.getElementById('main-edit-toggle');
                const mainSaveSection = document.getElementById('main-save-section');
                if (mainEditBtn) mainEditBtn.style.display = 'none';
                if (mainSaveSection) mainSaveSection.style.display = 'flex';
                
                // Enable all inputs
                viewMode.querySelectorAll('input, select, textarea').forEach(el => {
                    el.classList.add('editable');
                    el.removeAttribute('readonly');
                    el.removeAttribute('disabled');
                    el.style.background = 'white';
                });
                
                // Show field action buttons and add sections
                if (section === 'details') {
                    // Show promote/demote/remove buttons
                    document.querySelectorAll('.field-action-btn').forEach(btn => {
                        btn.style.display = 'inline-block';
                    });
                    // Show add metadata field section
                    const addMetadataSection = document.getElementById('add-metadata-field-section');
                    if (addMetadataSection) addMetadataSection.style.display = 'block';
                } else if (section === 'jsonb') {
                    const addSection = document.getElementById('add-jsonb-field-section');
                    if (addSection) addSection.style.display = 'block';
                } else if (section === 'relationships') {
                    // Show remove buttons and add relationship section
                    document.querySelectorAll('.relationship-actions').forEach(el => {
                        el.style.display = 'block';
                    });
                    const addRelSection = document.getElementById('add-relationship-section');
                    if (addRelSection) addRelSection.style.display = 'block';
                    
                    // Enable relationship fields (but not actor name/type which are read-only)
                    document.querySelectorAll('#relationships-view-mode input[id*="-relationship"], #relationships-view-mode input[id*="-role"], #relationships-view-mode input[id*="-role_category"], #relationships-view-mode input[id*="-start_date"], #relationships-view-mode input[id*="-end_date"], #relationships-view-mode input[id*="-is_primary"]').forEach(el => {
                        el.removeAttribute('readonly');
                        el.removeAttribute('disabled');
                        el.style.background = 'white';
                    });
                }
            } else {
                viewMode.classList.add('view-mode');
                saveSection.style.display = 'none';
                if (toggleBtn) {
                    toggleBtn.textContent = 'Edit';
                    toggleBtn.classList.remove('editing');
                }
                
                // Show the main edit button and hide save section
                const mainEditBtn = document.getElementById('main-edit-toggle');
                const mainSaveSection = document.getElementById('main-save-section');
                if (mainEditBtn) {
                    mainEditBtn.style.display = 'inline-block';
                    mainEditBtn.textContent = 'Edit Actor Details';
                }
                if (mainSaveSection) mainSaveSection.style.display = 'none';
                
                // Disable all inputs
                viewMode.querySelectorAll('input[type="text"], input[type="number"], input[type="date"], textarea').forEach(el => {
                    el.classList.remove('editable');
                    el.setAttribute('readonly', true);
                    el.style.background = '#f5f5f5';
                });
                viewMode.querySelectorAll('input[type="checkbox"], select').forEach(el => {
                    el.classList.remove('editable');
                    el.setAttribute('disabled', true);
                });
                
                // Hide field action buttons and add sections
                if (section === 'details') {
                    // Hide promote/demote/remove buttons
                    document.querySelectorAll('.field-action-btn').forEach(btn => {
                        btn.style.display = 'none';
                    });
                    // Hide add metadata field section
                    const addMetadataSection = document.getElementById('add-metadata-field-section');
                    if (addMetadataSection) addMetadataSection.style.display = 'none';
                } else if (section === 'jsonb') {
                    const addSection = document.getElementById('add-jsonb-field-section');
                    if (addSection) addSection.style.display = 'none';
                } else if (section === 'relationships') {
                    // Hide remove buttons and add relationship section
                    document.querySelectorAll('.relationship-actions').forEach(el => {
                        el.style.display = 'none';
                    });
                    const addRelSection = document.getElementById('add-relationship-section');
                    if (addRelSection) addRelSection.style.display = 'none';
                    
                    // Disable relationship fields (but keep actor name/type always read-only)
                    document.querySelectorAll('#relationships-view-mode input[id*="-relationship"], #relationships-view-mode input[id*="-role"], #relationships-view-mode input[id*="-role_category"], #relationships-view-mode input[id*="-start_date"], #relationships-view-mode input[id*="-end_date"], #relationships-view-mode input[id*="-is_primary"]').forEach(el => {
                        el.setAttribute('readonly', 'readonly');
                        el.setAttribute('disabled', 'disabled');
                        el.style.background = '#f5f5f5';
                    });
                }
            }
        }
        
        function cancelEditMode(section) {
            editMode[section] = false;
            toggleEditMode(section);
            // Reload original data
            loadActorDetailsForEdit();
        }
        
        async function saveRelationships() {
            if (!selectedActorForEdit || !window.currentRelationships) return;
            
            try {
                // Collect all updated relationship data
                const updatePromises = [];
                
                window.currentRelationships.forEach((link, index) => {
                    const linkId = `relationship-${index}`;
                    const relTypeElement = document.getElementById(`${linkId}-relationship`);
                    const roleElement = document.getElementById(`${linkId}-role`);
                    const roleCategoryElement = document.getElementById(`${linkId}-role_category`);
                    const startDateElement = document.getElementById(`${linkId}-start_date`);
                    const endDateElement = document.getElementById(`${linkId}-end_date`);
                    const isPrimaryElement = document.getElementById(`${linkId}-is_primary`);
                    
                    if (!relTypeElement) {
                        console.warn(`Elements not found for relationship ${index}`);
                        return;
                    }
                    
                    const relType = relTypeElement.value;
                    const role = roleElement ? roleElement.value : '';
                    const roleCategory = roleCategoryElement ? roleCategoryElement.value : '';
                    const startDate = startDateElement ? startDateElement.value : null;
                    const endDate = endDateElement ? endDateElement.value : null;
                    const isPrimary = isPrimaryElement ? isPrimaryElement.checked : false;
                    
                    // Update the relationship
                    const updateData = {
                        relationship: relType || link.relationship,
                        role: role || null,
                        role_category: roleCategory || null,
                        start_date: startDate || null,
                        end_date: endDate || null,
                        is_primary: isPrimary
                    };
                    
                    // Use v2_actor_links table - need to use the actor ID as from_actor_id
                    const updatePromise = supabaseRequest(
                        `v2_actor_links?from_actor_id=eq.${selectedActorForEdit.id}&to_actor_id=eq.${link.to_actor_id}&relationship=eq.${link.relationship}`,
                        {
                            method: 'PATCH',
                            body: JSON.stringify(updateData)
                        }
                    );
                    
                    updatePromises.push(updatePromise);
                });
                
                // Wait for all updates to complete
                await Promise.all(updatePromises);
                
                alert('Relationships saved successfully!');
                
                // Exit edit mode and reload
                editMode['relationships'] = false;
                toggleEditMode('relationships');
                await loadActorLinks(selectedActorForEdit.id);
                
            } catch (error) {
                console.error('Error saving relationships:', error);
                alert('Error saving relationships: ' + error.message);
            }
        }
        
        async function saveActorDetails() {
            if (!selectedActorForEdit) return;
            
            try {
                const actor = selectedActorForEdit;
                let updateData = {
                    name: document.getElementById('edit-name').value,
                    city: document.getElementById('edit-city').value || null,
                    state: document.getElementById('edit-state').value || null,
                    region: document.getElementById('edit-region').value || null,
                    about: document.getElementById('edit-about').value || null,
                    should_scrape: document.getElementById('edit-should_scrape').checked,
                    updated_at: new Date().toISOString()
                };
                
                // Collect indexed fields based on field mappings
                if (selectedFieldMappings && selectedFieldMappings.indexed) {
                    Object.entries(selectedFieldMappings.indexed).forEach(([fieldName, mapping]) => {
                        const element = document.getElementById(`edit-${mapping.column}`);
                        if (element) {
                            if (mapping.type === 'boolean' || mapping.type === 'bool') {
                                updateData[mapping.column] = element.checked;
                            } else if (mapping.type === 'numeric') {
                                const value = element.value;
                                updateData[mapping.column] = value ? parseFloat(value) : null;
                            } else {
                                updateData[mapping.column] = element.value || null;
                            }
                        }
                    });
                } else {
                    // Fallback to collecting all custom fields
                    for (let i = 1; i <= 10; i++) {
                        const textEl = document.getElementById(`edit-custom_text_${i}`);
                        if (textEl) updateData[`custom_text_${i}`] = textEl.value || null;
                    }
                    for (let i = 1; i <= 5; i++) {
                        const numEl = document.getElementById(`edit-custom_numeric_${i}`);
                        if (numEl && numEl.value) updateData[`custom_numeric_${i}`] = parseFloat(numEl.value);
                    }
                    for (let i = 1; i <= 3; i++) {
                        const dateEl = document.getElementById(`edit-custom_date_${i}`);
                        if (dateEl && dateEl.value) updateData[`custom_date_${i}`] = dateEl.value;
                    }
                    for (let i = 1; i <= 2; i++) {
                        const boolEl = document.getElementById(`edit-custom_bool_${i}`);
                        if (boolEl) updateData[`custom_bool_${i}`] = boolEl.checked;
                    }
                }
                
                // Collect metadata fields
                const metadataFields = {};
                document.querySelectorAll('[id^="metadata-"]').forEach(element => {
                    const fieldName = element.getAttribute('data-field');
                    if (fieldName) {
                        if (element.type === 'checkbox') {
                            metadataFields[fieldName] = element.checked;
                        } else {
                            metadataFields[fieldName] = element.value || null;
                        }
                    }
                });
                
                // Only include data field if there are metadata fields
                if (Object.keys(metadataFields).length > 0) {
                    updateData.data = metadataFields;
                }
                
                await supabaseRequest(`v2_actors?id=eq.${actor.id}`, {
                    method: 'PATCH',
                    body: JSON.stringify(updateData)
                });
                
                alert('Actor details updated successfully!');
                
                // Reload actor data
                const updatedData = await supabaseRequest(`v2_actors?id=eq.${actor.id}&select=*`);
                selectedActorForEdit = updatedData[0];
                
                // Exit edit mode
                toggleEditMode('details');
                
            } catch (error) {
                console.error('Error saving actor details:', error);
                alert('Error saving actor details: ' + error.message);
            }
        }
        
        async function loadActorRelationships(actorId) {
            try {
                // Load relationships using v2_actor_links table with correct foreign key names
                const fromLinks = await supabaseRequest(`v2_actor_links?from_actor_id=eq.${actorId}&select=*,to_actor:v2_actors!actor_links_to_actor_id_fkey(id,name,actor_type)`);
                
                const toLinks = await supabaseRequest(`v2_actor_links?to_actor_id=eq.${actorId}&select=*,from_actor:v2_actors!actor_links_from_actor_id_fkey(id,name,actor_type)`);
                
                displayActorRelationships(fromLinks, toLinks);
                
            } catch (error) {
                console.error('Error loading actor relationships:', error);
                document.getElementById('actor-links-list').innerHTML = 
                    '<div class="error-message">Error loading relationships: ' + error.message + '</div>';
            }
        }
        
        async function loadActorLinks(actorId) {
            try {
                // Load from actor_links table with proper foreign key references
                const fromLinks = await supabaseRequest(`v2_actor_links?from_actor_id=eq.${actorId}&select=*,to_actor:v2_actors!actor_links_to_actor_id_fkey(id,name,actor_type,city,state)`);
                
                const toLinks = await supabaseRequest(`v2_actor_links?to_actor_id=eq.${actorId}&select=*,from_actor:v2_actors!actor_links_from_actor_id_fkey(id,name,actor_type,city,state)`);
                
                displayActorLinks(fromLinks, toLinks);
                
            } catch (error) {
                console.error('Error loading actor links:', error);
                document.getElementById('actor-links-list').innerHTML = 
                    '<div style="color: #666; font-size: 16px; padding: 20px; text-align: center;">No relationships found</div>';
            }
        }
        
        function displayActorRelationshipsFromData(relationships) {
            console.log('🎨 Displaying relationships from data:', relationships);
            
            let html = '';
            
            if (!relationships || relationships.length === 0) {
                console.log('  ❌ No relationships to display');
                html += '<div style="color: #666; font-size: 16px; padding: 20px; text-align: center;">No relationships found</div>';
            } else {
                console.log(`  ✅ Displaying ${relationships.length} relationships`);
                html += '<div class="relationships-container" style="font-size: 16px;">';
                html += '<h3 style="color: #333; margin-bottom: 15px; font-size: 18px;">Relationships to Other Actors</h3>';
                
                relationships.forEach((link, index) => {
                    const linkId = `relationship-${index}`;
                    const isPrimary = link.is_primary ? 'checked' : '';
                    const startDate = link.start_date ? link.start_date.split('T')[0] : '';
                    const endDate = link.end_date ? link.end_date.split('T')[0] : '';
                    
                    html += `
                        <div class="relationship-item" style="background: #f8f9fa; padding: 20px; margin-bottom: 15px; border-radius: 8px; border: 1px solid #dee2e6;">
                            <div class="form-grid-2">
                                <div class="form-group">
                                    <label style="font-weight: 600; color: #495057;">Related Actor</label>
                                    <input type="text" value="${link.target_name || 'Unknown'}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                </div>
                                <div class="form-group">
                                    <label style="font-weight: 600; color: #495057;">Actor Type</label>
                                    <input type="text" value="${link.target_type || 'unknown'}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                </div>
                                <div class="form-group">
                                    <label style="font-weight: 600; color: #495057;">Relationship Type</label>
                                    <input type="text" id="${linkId}-relationship" data-link-id="${link.to_actor_id}" value="${link.relationship || ''}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                </div>
                                <div class="form-group">
                                    <label style="font-weight: 600; color: #495057;">Role</label>
                                    <input type="text" id="${linkId}-role" data-link-id="${link.to_actor_id}" value="${link.role || ''}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                </div>
                                <div class="form-group">
                                    <label style="font-weight: 600; color: #495057;">Role Category</label>
                                    <input type="text" id="${linkId}-role_category" data-link-id="${link.to_actor_id}" value="${link.role_category || ''}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                </div>
                                <div class="form-group">
                                    <label style="font-weight: 600; color: #495057;">Start Date</label>
                                    <input type="date" id="${linkId}-start_date" data-link-id="${link.to_actor_id}" value="${startDate}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                </div>
                                <div class="form-group">
                                    <label style="font-weight: 600; color: #495057;">End Date</label>
                                    <input type="date" id="${linkId}-end_date" data-link-id="${link.to_actor_id}" value="${endDate}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                </div>
                                <div class="form-group" style="grid-column: 1 / -1;">
                                    <label class="checkbox-label" style="font-size: 16px;">
                                        <input type="checkbox" id="${linkId}-is_primary" data-link-id="${link.to_actor_id}" ${isPrimary} disabled style="margin-right: 8px;">
                                        <span style="font-weight: 600; color: #495057;">Primary Relationship</span>
                                    </label>
                                </div>
                            </div>
                            <div class="relationship-actions" style="margin-top: 15px; display: none;">
                                <button class="btn btn-danger" onclick="removeActorLink('${selectedActorForEdit.id}', '${link.to_actor_id}', '${link.relationship}')" style="padding: 8px 16px; font-size: 14px;">Remove Relationship</button>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            // Store relationships data for saving
            window.currentRelationships = relationships;
            
            document.getElementById('actor-links-list').innerHTML = html;
        }
        
        function displayActorRelationships(fromLinks, toLinks) {
            let html = '<h4 style="color: #4facfe;">Actor Relationships</h4>';
            
            if (fromLinks.length === 0 && toLinks.length === 0) {
                html += '<div class="no-results">No relationships defined</div>';
            } else {
                html += '<div class="linked-actors-list">';
                
                // Display outgoing relationships
                if (fromLinks.length > 0) {
                    html += '<h5 style="margin-top: 15px;">Relationships to Other Actors:</h5>';
                    fromLinks.forEach(link => {
                        const isPrimary = link.is_primary ? ' <span style="color: #28a745; font-weight: bold;">[PRIMARY]</span>' : '';
                        const dateRange = formatDateRange(link.start_date, link.end_date);
                        html += `
                            <div class="linked-actor-item">
                                <div class="linked-actor-info">
                                    <strong>${link.to_actor.name}</strong> (${link.to_actor.actor_type})${isPrimary}
                                    <br><small>Relationship: ${link.relationship}</small>
                                    ${link.role ? `<br><small>Role: ${link.role}</small>` : ''}
                                    ${dateRange ? `<br><small>${dateRange}</small>` : ''}
                                </div>
                                <button class="remove-link-btn" onclick="removeActorLink('${link.from_actor_id}', '${link.to_actor_id}', '${link.relationship}')">Remove</button>
                            </div>
                        `;
                    });
                }
                
                // Display incoming relationships
                if (toLinks.length > 0) {
                    html += '<h5 style="margin-top: 15px;">Relationships from Other Actors:</h5>';
                    toLinks.forEach(link => {
                        const isPrimary = link.is_primary ? ' <span style="color: #28a745; font-weight: bold;">[PRIMARY]</span>' : '';
                        const dateRange = formatDateRange(link.start_date, link.end_date);
                        html += `
                            <div class="linked-actor-item">
                                <div class="linked-actor-info">
                                    <strong>${link.from_actor.name}</strong> (${link.from_actor.actor_type})${isPrimary}
                                    <br><small>Has relationship: ${link.relationship}</small>
                                    ${link.role ? `<br><small>Their role: ${link.role}</small>` : ''}
                                    ${dateRange ? `<br><small>${dateRange}</small>` : ''}
                                </div>
                            </div>
                        `;
                    });
                }
                
                html += '</div>';
            }
            
            document.getElementById('actor-links-list').innerHTML = html;
        }
        
        function formatDateRange(startDate, endDate) {
            if (!startDate) return '';
            
            const start = new Date(startDate).toLocaleDateString();
            if (!endDate) {
                return `Since ${start}`;
            }
            const end = new Date(endDate).toLocaleDateString();
            return `${start} - ${end}`;
        }
        
        function displayActorLinks(fromLinks, toLinks) {
            let html = '';
            
            if (fromLinks.length === 0 && toLinks.length === 0) {
                html += '<div style="color: #666; font-size: 16px; padding: 20px; text-align: center;">No relationships found</div>';
            } else {
                html += '<div class="relationships-container" style="font-size: 16px;">';
                
                // Display outgoing relationships
                if (fromLinks.length > 0) {
                    html += '<h3 style="color: #333; margin-bottom: 15px; font-size: 18px;">Relationships to Other Actors</h3>';
                    fromLinks.forEach((link, index) => {
                        const linkId = `relationship-${index}`;
                        const isPrimary = link.is_primary ? 'checked' : '';
                        const startDate = link.start_date ? link.start_date.split('T')[0] : '';
                        const endDate = link.end_date ? link.end_date.split('T')[0] : '';
                        
                        html += `
                            <div class="relationship-item" style="background: #f8f9fa; padding: 20px; margin-bottom: 15px; border-radius: 8px; border: 1px solid #dee2e6;">
                                <div class="form-grid-2">
                                    <div class="form-group">
                                        <label style="font-weight: 600; color: #495057;">Related Actor</label>
                                        <input type="text" value="${link.to_actor.name}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                    </div>
                                    <div class="form-group">
                                        <label style="font-weight: 600; color: #495057;">Actor Type</label>
                                        <input type="text" value="${link.to_actor.actor_type}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                    </div>
                                    <div class="form-group">
                                        <label style="font-weight: 600; color: #495057;">Relationship Type</label>
                                        <input type="text" id="${linkId}-relationship" data-link-id="${link.id}" value="${link.relationship || ''}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                    </div>
                                    <div class="form-group">
                                        <label style="font-weight: 600; color: #495057;">Role</label>
                                        <input type="text" id="${linkId}-role" data-link-id="${link.id}" value="${link.role || ''}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                    </div>
                                    <div class="form-group">
                                        <label style="font-weight: 600; color: #495057;">Start Date</label>
                                        <input type="date" id="${linkId}-start_date" data-link-id="${link.id}" value="${startDate}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                    </div>
                                    <div class="form-group">
                                        <label style="font-weight: 600; color: #495057;">End Date</label>
                                        <input type="date" id="${linkId}-end_date" data-link-id="${link.id}" value="${endDate}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                    </div>
                                    <div class="form-group" style="grid-column: 1 / -1;">
                                        <label class="checkbox-label" style="font-size: 16px;">
                                            <input type="checkbox" id="${linkId}-is_primary" data-link-id="${link.id}" ${isPrimary} disabled style="margin-right: 8px;">
                                            <span style="font-weight: 600; color: #495057;">Primary Relationship</span>
                                        </label>
                                    </div>
                                </div>
                                <div class="relationship-actions" style="margin-top: 15px; display: none;">
                                    <button class="btn btn-danger" onclick="removeActorLink('${link.from_actor_id}', '${link.to_actor_id}', '${link.relationship}')" style="padding: 8px 16px; font-size: 14px;">Remove Relationship</button>
                                </div>
                            </div>
                        `;
                    });
                }
                
                // Display incoming relationships
                if (toLinks.length > 0) {
                    html += '<h3 style="color: #333; margin: 20px 0 15px 0; font-size: 18px;">Relationships from Other Actors</h3>';
                    toLinks.forEach((link, index) => {
                        const linkId = `incoming-relationship-${index}`;
                        html += `
                            <div class="relationship-item" style="background: #fff4e6; padding: 20px; margin-bottom: 15px; border-radius: 8px; border: 1px solid #ffc107;">
                                <div class="form-grid-2">
                                    <div class="form-group">
                                        <label style="font-weight: 600; color: #495057;">Related Actor</label>
                                        <input type="text" value="${link.from_actor.name}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                    </div>
                                    <div class="form-group">
                                        <label style="font-weight: 600; color: #495057;">Actor Type</label>
                                        <input type="text" value="${link.from_actor.actor_type}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                    </div>
                                    <div class="form-group" style="grid-column: 1 / -1;">
                                        <label style="font-weight: 600; color: #495057;">Relationship</label>
                                        <input type="text" value="${link.from_actor.name} is ${link.relationship} to ${selectedActorForEdit.name}" readonly style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background: #f5f5f5; font-size: 16px;">
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                }
                
                html += '</div>';
            }
            
            // Store relationships data for saving
            window.currentRelationships = fromLinks;
            
            document.getElementById('actor-links-list').innerHTML = html;
        }
        
        async function removeActorLink(fromId, toId, relType) {
            if (!confirm('Are you sure you want to remove this relationship?')) return;
            
            try {
                await supabaseRequest(`v2_actor_links?from_actor_id=eq.${fromId}&to_actor_id=eq.${toId}&relationship=eq.${relType}`, {
                    method: 'DELETE'
                });
                
                // Reload links
                await loadActorLinks(selectedActorForEdit.id);
                
            } catch (error) {
                console.error('Error removing relationship:', error);
                alert('Error removing relationship: ' + error.message);
            }
        }
        
        function debouncedSearchForLinking() {
            clearTimeout(linkSearchTimeout);
            linkSearchTimeout = setTimeout(searchForLinking, 300);
        }
        
        async function searchForLinking() {
            const searchTerm = document.getElementById('link-actor-search').value.trim();
            
            if (!searchTerm || searchTerm.length < 2) {
                document.getElementById('link-search-results').innerHTML = '';
                return;
            }
            
            try {
                // Use % for SQL wildcards and also search in city/state
                // Note: Don't encode the search term as it breaks PostgreSQL's ilike pattern matching for spaces
                const searchPattern = `%${searchTerm}%`;
                const results = await supabaseRequest(`v2_actors?select=*&or=(name.ilike.${searchPattern},city.ilike.${searchPattern},state.ilike.${searchPattern})&order=name&limit=20`);
                
                let html = '';
                if (results && results.length > 0) {
                    results.forEach(actor => {
                        // Exclude the current actor being edited
                        if (actor.id !== selectedActorForEdit.id) {
                            // Escape the name for onclick
                            const escapedName = actor.name.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                            const location = [actor.city, actor.state].filter(Boolean).join(', ');
                            
                            html += `
                                <div style="padding: 10px; background: white; margin: 4px 0; border-radius: 4px; cursor: pointer; border: 1px solid #e0e0e0;" 
                                     onclick="selectActorForLinking('${actor.id}', '${escapedName}')"
                                     onmouseover="this.style.background='#f0f7ff'; this.style.borderColor='#007bff';" 
                                     onmouseout="this.style.background='white'; this.style.borderColor='#e0e0e0';">
                                    <strong style="color: #333;">${actor.name}</strong> 
                                    <span style="color: #666; font-size: 12px;">(${actor.actor_type})</span>
                                    ${location ? `<br><small style="color: #999;">${location}</small>` : ''}
                                </div>
                            `;
                        }
                    });
                } else {
                    html = '<div style="padding: 10px; color: #666;">No actors found matching your search</div>';
                }
                
                document.getElementById('link-search-results').innerHTML = html;
                
            } catch (error) {
                console.error('Error searching for actors:', error);
                document.getElementById('link-search-results').innerHTML = '<div style="padding: 10px; color: red;">Error searching actors</div>';
            }
        }
        
        function selectActorForLinking(actorId, actorName) {
            tempSelectedLinkActor = { id: actorId, name: actorName };
            
            document.getElementById('selected-link-actor').style.display = 'block';
            document.getElementById('selected-link-name').textContent = actorName;
            document.getElementById('link-search-results').innerHTML = '';
            document.getElementById('link-actor-search').value = '';
            
            // Populate relationship types based on actor type
            const relSelect = document.getElementById('link-relationship-type');
            let options = '';
            
            if (selectedActorForEdit.actor_type === 'person') {
                options = `
                    <option value="works_for">Works For</option>
                    <option value="affiliated_with">Affiliated With</option>
                    <option value="member_of">Member Of</option>
                    <option value="collaborates_with">Collaborates With</option>
                `;
            } else if (selectedActorForEdit.actor_type === 'organization') {
                options = `
                    <option value="parent_of">Parent Of</option>
                    <option value="subsidiary_of">Subsidiary Of</option>
                    <option value="partner_with">Partner With</option>
                    <option value="affiliated_with">Affiliated With</option>
                `;
            } else if (selectedActorForEdit.actor_type === 'chapter') {
                options = `
                    <option value="part_of">Part Of</option>
                    <option value="affiliated_with">Affiliated With</option>
                    <option value="collaborates_with">Collaborates With</option>
                `;
            }
            
            relSelect.innerHTML = options;
        }
        
        function clearLinkSelection() {
            tempSelectedLinkActor = null;
            document.getElementById('selected-link-actor').style.display = 'none';
            document.getElementById('link-actor-search').value = '';
        }
        
        async function addActorLink() {
            if (!tempSelectedLinkActor || !selectedActorForEdit) return;
            
            const relType = document.getElementById('link-relationship-type').value;
            const role = document.getElementById('link-role') ? document.getElementById('link-role').value : '';
            const startDate = document.getElementById('link-start-date') ? document.getElementById('link-start-date').value : null;
            const endDate = document.getElementById('link-end-date') ? document.getElementById('link-end-date').value : null;
            const isPrimary = document.getElementById('link-is-primary') ? document.getElementById('link-is-primary').checked : false;
            
            if (!relType) {
                alert('Please enter a relationship type');
                return;
            }
            
            try {
                // Use v2_actor_links table with all fields
                await supabaseRequest('v2_actor_links', {
                    method: 'POST',
                    body: JSON.stringify({
                        from_actor_id: selectedActorForEdit.id,
                        to_actor_id: tempSelectedLinkActor.id,
                        relationship: relType,
                        role: role || null,
                        start_date: startDate,
                        end_date: endDate,
                        is_primary: isPrimary,
                        created_at: new Date().toISOString()
                    })
                });
                
                // Clear selection and form
                clearLinkSelection();
                if (document.getElementById('link-relationship-type')) document.getElementById('link-relationship-type').value = '';
                if (document.getElementById('link-role')) document.getElementById('link-role').value = '';
                if (document.getElementById('link-start-date')) document.getElementById('link-start-date').value = '';
                if (document.getElementById('link-end-date')) document.getElementById('link-end-date').value = '';
                if (document.getElementById('link-is-primary')) document.getElementById('link-is-primary').checked = false;
                
                // Reload links
                await loadActorLinks(selectedActorForEdit.id);
                
                alert('Relationship added successfully!');
                
            } catch (error) {
                console.error('Error adding relationship:', error);
                alert('Error adding relationship: ' + error.message);
            }
        }
        
        function debouncedSearchActorsForEdit() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(searchActorsForEdit, 300);
        }
        
        async function searchActorsForEdit() {
            const searchTerm = document.getElementById('edit-actor-search').value.toLowerCase().trim();
            
            if (!searchTerm || searchTerm.length < 2) {
                loadActorsForEdit();
                return;
            }

            try {
                document.getElementById('edit-actors-list').innerHTML = '<div class="loading">Searching...</div>';

                // Include primary relationships in search results
                const results = await supabaseRequest(`v2_actors?select=*,primary_relationships:v2_actor_links!actor_links_from_actor_id_fkey(relationship,role,is_primary,to_actor:v2_actors!actor_links_to_actor_id_fkey(id,name,actor_type))&or=(name.ilike.*${searchTerm}*,city.ilike.*${searchTerm}*,state.ilike.*${searchTerm}*)&order=name&limit=50`);
                
                // Filter to only keep primary relationships
                results.forEach(actor => {
                    if (actor.primary_relationships) {
                        actor.primary_relationship = actor.primary_relationships.find(rel => rel.is_primary === true) || actor.primary_relationships[0];
                        delete actor.primary_relationships;
                    }
                });
                
                displayActorsForEdit(results);

            } catch (error) {
                console.error('Error searching actors:', error);
                document.getElementById('edit-actors-list').innerHTML = 
                    `<div class="error-message">Error searching actors: ${error.message}</div>`;
            }
        }
        
        async function openInlineEdit(actorId) {
            console.log('Opening inline edit for actor:', actorId);
            
            try {
                // Load complete actor data using the optimized SQL function
                const actorData = await callSupabaseFunction('get_actor_complete_data', {
                    actor_id_param: actorId
                });
                console.log('Complete actor data loaded:', actorData);
                
                if (!actorData || actorData.length === 0) {
                    throw new Error('Actor not found');
                }
                
                selectedActorForEdit = actorData[0];
                
                // Debug logging to understand data structure
                console.log('🔍 Actor data structure check:');
                console.log('  - Has metadata_fields?', !!selectedActorForEdit.metadata_fields);
                console.log('  - metadata_fields:', selectedActorForEdit.metadata_fields);
                console.log('  - Has relationships?', !!selectedActorForEdit.relationships);
                console.log('  - relationships:', selectedActorForEdit.relationships);
                selectedActorForUsername = { 
                    id: actorId, 
                    name: selectedActorForEdit.name, 
                    actor_type: selectedActorForEdit.actor_type  // Changed from 'type' to 'actor_type'
                };
                
                // Hide actor list and show edit section
                document.getElementById('actor-list-section').style.display = 'none';
                document.getElementById('inline-edit-section').style.display = 'block';
                document.getElementById('editing-actor-name').textContent = `Edit: ${selectedActorForEdit.name}`;
                
                // Load all sections
                await loadActorDetailsForEdit();
                
            } catch (error) {
                console.error('Error opening inline edit:', error);
                alert('Error loading actor details: ' + error.message);
            }
        }
        
        function closeInlineEdit() {
            // Show actor list and hide edit section
            document.getElementById('actor-list-section').style.display = 'block';
            document.getElementById('inline-edit-section').style.display = 'none';
            selectedActorForEdit = null;
            selectedActorForUsername = null;
            editMode = {
                details: false,
                usernames: false,
                links: false,
                relationships: false,
                jsonb: false
            };
            
            // Reload the actor list to show any changes
            loadExistingActorsMain();
        }
        
        async function saveJsonbData() {
            if (!selectedActorForEdit) return;
            
            try {
                const actor = selectedActorForEdit;
                
                // Build JSONB data from individual fields
                let jsonData = {};
                
                // Get all JSONB fields
                const jsonbFields = document.querySelectorAll('.jsonb-field');
                jsonbFields.forEach(field => {
                    const path = field.getAttribute('data-path');
                    const value = field.value.trim();
                    
                    if (value) {
                        // Handle nested paths (e.g., "misc.notes")
                        const keys = path.split('.');
                        if (keys.length > 1) {
                            // Create nested object
                            if (!jsonData[keys[0]]) {
                                jsonData[keys[0]] = {};
                            }
                            jsonData[keys[0]][keys[1]] = value;
                        } else {
                            // Direct property
                            jsonData[keys[0]] = value;
                        }
                    }
                });
                
                let updateData = {
                    data: jsonData,
                    updated_at: new Date().toISOString()
                };
                
                await supabaseRequest(`v2_actors?id=eq.${actor.id}`, {
                    method: 'PATCH',
                    body: JSON.stringify(updateData)
                });
                
                alert('Additional data updated successfully!');
                
                // Reload actor data
                const updatedData = await supabaseRequest(`v2_actors?id=eq.${actor.id}&select=*`);
                selectedActorForEdit = updatedData[0];
                
                // Exit edit mode and reload the JSONB fields
                toggleEditMode('jsonb');
                loadJsonbDataForEdit();
                
            } catch (error) {
                console.error('Error saving JSONB data:', error);
                alert('Error saving JSONB data: ' + error.message);
            }
        }
        
        // Actor linking functions for promote/create forms
        function toggleActorLinking() {
            const section = document.getElementById('actor-linking-section');
            const enabled = document.getElementById('enable-actor-links').checked;
            section.style.display = enabled ? 'block' : 'none';
            if (!enabled) {
                selectedLinkedActors = [];
                document.getElementById('promote-linked-actors').innerHTML = '';
            }
        }
        
        function toggleNewActorLinking() {
            const section = document.getElementById('new-actor-linking-section');
            const enabled = document.getElementById('new-enable-actor-links').checked;
            section.style.display = enabled ? 'block' : 'none';
            if (!enabled) {
                selectedLinkedActors = [];
                document.getElementById('new-linked-actors').innerHTML = '';
            }
        }
        
        let promoteSearchTimeout = null;
        function debouncedSearchPromoteLinks() {
            clearTimeout(promoteSearchTimeout);
            promoteSearchTimeout = setTimeout(searchPromoteLinks, 300);
        }
        
        async function searchPromoteLinks() {
            const searchTerm = document.getElementById('promote-link-search').value.trim();
            
            if (!searchTerm || searchTerm.length < 2) {
                document.getElementById('promote-link-results').innerHTML = '';
                return;
            }
            
            try {
                // Use the search_similar_v2_actors function for better results
                const results = await callSupabaseFunction('search_similar_v2_actors', {
                    p_search_term: searchTerm,
                    p_bio_text: currentUnknownActor ? currentUnknownActor.profile_bio : null,
                    p_limit: 20
                });
                
                let html = '';
                results.forEach(actor => {
                    if (!selectedLinkedActors.find(a => a.id === actor.id)) {
                        html += `
                            <div style="padding: 8px; background: white; margin: 2px 0; border-radius: 4px; cursor: pointer;" 
                                 onclick="addPromoteLink('${actor.id}', '${actor.name.replace(/'/g, "\\'")}')"
                                 onmouseover="this.style.background='#f0f0f0'" 
                                 onmouseout="this.style.background='white'">
                                <strong>${actor.name}</strong> (${actor.actor_type})
                            </div>
                        `;
                    }
                });
                
                document.getElementById('promote-link-results').innerHTML = html || '<div class="no-results">No actors found</div>';
                
            } catch (error) {
                console.error('Error searching for actors:', error);
            }
        }
        
        function addPromoteLink(actorId, actorName) {
            selectedLinkedActors.push({ id: actorId, name: actorName });
            document.getElementById('promote-link-search').value = '';
            document.getElementById('promote-link-results').innerHTML = '';
            displayPromoteLinkedActors();
        }
        
        function displayPromoteLinkedActors() {
            let html = '';
            
            selectedLinkedActors.forEach((actor, index) => {
                html += `
                    <div class="linked-actor-item" style="border: 1px solid #ddd; padding: 15px; margin: 10px 0; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <strong style="font-size: 16px;">${actor.name}</strong>
                            <button class="remove-link-btn" onclick="removePromoteLink(${index})" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">Remove</button>
                        </div>
                        
                        <div class="relationship-fields" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div class="form-group">
                                <label>Relationship Type <span style="color: red;">*</span></label>
                                <select id="promote-rel-${index}" onchange="updateRelationshipFields(${index})">
                                    <option value="">Select relationship...</option>
                                    <option value="Staff">Staff</option>
                                    <option value="Member">Member</option>
                                    <option value="Advisor">Advisor</option>
                                    <option value="Alumni">Alumni</option>
                                    <option value="Partner">Partner</option>
                                    <option value="Affiliate">Affiliate</option>
                                    <option value="Board Member">Board Member</option>
                                    <option value="Volunteer">Volunteer</option>
                                    <option value="Donor">Donor</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label>Role</label>
                                <input type="text" id="promote-role-${index}" placeholder="e.g., Field Representative">
                            </div>
                            
                            <div class="form-group">
                                <label>Role Category</label>
                                <input type="text" id="promote-role-cat-${index}" placeholder="e.g., College Program">
                            </div>
                            
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="promote-primary-${index}">
                                    Primary Relationship
                                </label>
                            </div>
                            
                            <div class="form-group">
                                <label>Start Date</label>
                                <input type="date" id="promote-start-${index}">
                            </div>
                            
                            <div class="form-group">
                                <label>End Date</label>
                                <input type="date" id="promote-end-${index}">
                            </div>
                        </div>
                        
                        <div class="metadata-section" style="margin-top: 10px;">
                            <label style="font-weight: bold;">Additional Fields:</label>
                            <div id="promote-metadata-${index}" style="margin-top: 5px;">
                                <button type="button" onclick="addMetadataField(${index})" style="background: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">+ Add Field</button>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            document.getElementById('promote-linked-actors').innerHTML = html;
        }
        
        function removePromoteLink(index) {
            selectedLinkedActors.splice(index, 1);
            displayPromoteLinkedActors();
        }
        
        // Add metadata field to a relationship
        function addMetadataField(linkIndex) {
            const metadataDiv = document.getElementById(`promote-metadata-${linkIndex}`);
            const fieldIndex = metadataDiv.querySelectorAll('.metadata-field').length;
            
            const fieldHtml = `
                <div class="metadata-field" style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; margin-top: 5px;">
                    <input type="text" id="promote-meta-key-${linkIndex}-${fieldIndex}" placeholder="Field name" style="padding: 5px;">
                    <input type="text" id="promote-meta-value-${linkIndex}-${fieldIndex}" placeholder="Field value" style="padding: 5px;">
                    <button type="button" onclick="removeMetadataField(${linkIndex}, this)" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">×</button>
                </div>
            `;
            
            // Insert before the add button
            const addButton = metadataDiv.querySelector('button');
            const newField = document.createElement('div');
            newField.innerHTML = fieldHtml;
            metadataDiv.insertBefore(newField.firstElementChild, addButton);
        }
        
        // Remove metadata field
        function removeMetadataField(linkIndex, button) {
            button.parentElement.remove();
        }
        
        // Update relationship fields based on type
        function updateRelationshipFields(index) {
            const relType = document.getElementById(`promote-rel-${index}`).value;
            
            // Pre-fill role based on relationship type
            const roleField = document.getElementById(`promote-role-${index}`);
            const roleCatField = document.getElementById(`promote-role-cat-${index}`);
            
            switch(relType) {
                case 'Staff':
                    if (!roleField.value) roleField.placeholder = 'e.g., Field Representative, Marketing Director';
                    if (!roleCatField.value) roleCatField.placeholder = 'e.g., College Program, Leadership';
                    break;
                case 'Member':
                    if (!roleField.value) roleField.placeholder = 'e.g., Active Member, Chapter President';
                    if (!roleCatField.value) roleCatField.placeholder = 'e.g., Student, Professional';
                    break;
                case 'Advisor':
                    if (!roleField.value) roleField.placeholder = 'e.g., Faculty Advisor, Strategic Advisor';
                    if (!roleCatField.value) roleCatField.placeholder = 'e.g., Academic, Business';
                    break;
                default:
                    roleField.placeholder = 'e.g., Field Representative';
                    roleCatField.placeholder = 'e.g., College Program';
            }
        }
        
        function getRelationshipOptions(actorType) {
            if (actorType === 'person') {
                return `
                    <option value="works_for">Works For</option>
                    <option value="affiliated_with">Affiliated With</option>
                    <option value="member_of">Member Of</option>
                `;
            } else if (actorType === 'organization') {
                return `
                    <option value="parent_of">Parent Of</option>
                    <option value="subsidiary_of">Subsidiary Of</option>
                    <option value="partner_with">Partner With</option>
                `;
            } else if (actorType === 'chapter') {
                return `
                    <option value="part_of">Part Of</option>
                    <option value="affiliated_with">Affiliated With</option>
                `;
            }
            return '';
        }
        
        let newSearchTimeout = null;
        function debouncedSearchNewLinks() {
            clearTimeout(newSearchTimeout);
            newSearchTimeout = setTimeout(searchNewLinks, 300);
        }
        
        async function searchNewLinks() {
            const searchTerm = document.getElementById('new-link-search').value.trim();
            
            if (!searchTerm || searchTerm.length < 2) {
                document.getElementById('new-link-results').innerHTML = '';
                return;
            }
            
            try {
                const results = await supabaseRequest(`v2_actors?select=*&name=ilike.*${encodeURIComponent(searchTerm)}*&limit=10`);
                
                let html = '';
                results.forEach(actor => {
                    if (!selectedLinkedActors.find(a => a.id === actor.id)) {
                        html += `
                            <div style="padding: 8px; background: white; margin: 2px 0; border-radius: 4px; cursor: pointer;" 
                                 onclick="addNewLink('${actor.id}', '${actor.name.replace(/'/g, "\\'")}')"
                                 onmouseover="this.style.background='#f0f0f0'" 
                                 onmouseout="this.style.background='white'">
                                <strong>${actor.name}</strong> (${actor.actor_type})
                            </div>
                        `;
                    }
                });
                
                document.getElementById('new-link-results').innerHTML = html || '<div class="no-results">No actors found</div>';
                
            } catch (error) {
                console.error('Error searching for actors:', error);
            }
        }
        
        function addNewLink(actorId, actorName) {
            selectedLinkedActors.push({ id: actorId, name: actorName });
            document.getElementById('new-link-search').value = '';
            document.getElementById('new-link-results').innerHTML = '';
            displayNewLinkedActors();
        }
        
        function displayNewLinkedActors() {
            let html = '';
            
            selectedLinkedActors.forEach((actor, index) => {
                html += `
                    <div class="linked-actor-item" style="border: 1px solid #ddd; padding: 15px; margin: 10px 0; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <strong style="font-size: 16px;">${actor.name}</strong>
                            <button class="remove-link-btn" onclick="removeNewLink(${index})" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">Remove</button>
                        </div>
                        
                        <div class="relationship-fields" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div class="form-group">
                                <label>Relationship Type <span style="color: red;">*</span></label>
                                <select id="new-rel-${index}" onchange="updateNewRelationshipFields(${index})">
                                    <option value="">Select relationship...</option>
                                    <option value="Staff">Staff</option>
                                    <option value="Member">Member</option>
                                    <option value="Advisor">Advisor</option>
                                    <option value="Alumni">Alumni</option>
                                    <option value="Partner">Partner</option>
                                    <option value="Affiliate">Affiliate</option>
                                    <option value="Board Member">Board Member</option>
                                    <option value="Volunteer">Volunteer</option>
                                    <option value="Donor">Donor</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label>Role</label>
                                <input type="text" id="new-role-${index}" placeholder="e.g., Field Representative">
                            </div>
                            
                            <div class="form-group">
                                <label>Role Category</label>
                                <input type="text" id="new-role-cat-${index}" placeholder="e.g., College Program">
                            </div>
                            
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="new-primary-${index}">
                                    Primary Relationship
                                </label>
                            </div>
                            
                            <div class="form-group">
                                <label>Start Date</label>
                                <input type="date" id="new-start-${index}">
                            </div>
                            
                            <div class="form-group">
                                <label>End Date</label>
                                <input type="date" id="new-end-${index}">
                            </div>
                        </div>
                        
                        <div class="metadata-section" style="margin-top: 10px;">
                            <label style="font-weight: bold;">Additional Fields:</label>
                            <div id="new-metadata-${index}" style="margin-top: 5px;">
                                <button type="button" onclick="addNewMetadataField(${index})" style="background: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">+ Add Field</button>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            document.getElementById('new-linked-actors').innerHTML = html;
        }
        
        function removeNewLink(index) {
            selectedLinkedActors.splice(index, 1);
            displayNewLinkedActors();
        }
        
        // Add metadata field to new actor relationship
        function addNewMetadataField(linkIndex) {
            const metadataDiv = document.getElementById(`new-metadata-${linkIndex}`);
            const fieldIndex = metadataDiv.querySelectorAll('.metadata-field').length;
            
            const fieldHtml = `
                <div class="metadata-field" style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; margin-top: 5px;">
                    <input type="text" id="new-meta-key-${linkIndex}-${fieldIndex}" placeholder="Field name" style="padding: 5px;">
                    <input type="text" id="new-meta-value-${linkIndex}-${fieldIndex}" placeholder="Field value" style="padding: 5px;">
                    <button type="button" onclick="removeNewMetadataField(${linkIndex}, this)" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">×</button>
                </div>
            `;
            
            // Insert before the add button
            const addButton = metadataDiv.querySelector('button');
            const newField = document.createElement('div');
            newField.innerHTML = fieldHtml;
            metadataDiv.insertBefore(newField.firstElementChild, addButton);
        }
        
        // Remove metadata field from new actor form
        function removeNewMetadataField(linkIndex, button) {
            button.parentElement.remove();
        }
        
        // Update new relationship fields based on type
        function updateNewRelationshipFields(index) {
            const relType = document.getElementById(`new-rel-${index}`).value;
            
            // Pre-fill role based on relationship type
            const roleField = document.getElementById(`new-role-${index}`);
            const roleCatField = document.getElementById(`new-role-cat-${index}`);
            
            switch(relType) {
                case 'Staff':
                    if (!roleField.value) roleField.placeholder = 'e.g., Field Representative, Marketing Director';
                    if (!roleCatField.value) roleCatField.placeholder = 'e.g., College Program, Leadership';
                    break;
                case 'Member':
                    if (!roleField.value) roleField.placeholder = 'e.g., Active Member, Chapter President';
                    if (!roleCatField.value) roleCatField.placeholder = 'e.g., Student, Professional';
                    break;
                case 'Advisor':
                    if (!roleField.value) roleField.placeholder = 'e.g., Faculty Advisor, Strategic Advisor';
                    if (!roleCatField.value) roleCatField.placeholder = 'e.g., Academic, Business';
                    break;
                default:
                    roleField.placeholder = 'e.g., Field Representative';
                    roleCatField.placeholder = 'e.g., College Program';
            }
        }
        
        // Old username management functions (kept for compatibility)
        function openManageUsernamesModal() {
            selectedActorForUsername = null;
            document.getElementById('username-actor-search').value = '';
            document.getElementById('username-management-section').style.display = 'none';
            document.getElementById('manage-usernames-modal').style.display = 'block';
            
            loadActorsForUsernames();
        }

        async function loadActorsForUsernames() {
            try {
                document.getElementById('username-actors-list').innerHTML = '<div class="loading">Loading actors...</div>';
                
                const actors = await supabaseRequest('v2_actors?select=*&order=name&limit=100');
                
                displayActorsForUsernames(actors);
                
            } catch (error) {
                console.error('Error loading actors:', error);
                document.getElementById('username-actors-list').innerHTML = 
                    '<div class="error-message">Error loading actors</div>';
            }
        }

        function displayActorsForUsernames(actors) {
            if (actors.length === 0) {
                document.getElementById('username-actors-list').innerHTML = 
                    '<div class="no-results">No actors found</div>';
                return;
            }

            let tableHTML = `
                <table class="existing-actors-table">
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Name</th>
                            <th>Details</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            actors.forEach(actor => {
                const details = getActorDetails(actor);
                
                tableHTML += `
                    <tr>
                        <td>${actor.actor_type}</td>
                        <td><strong>${actor.name}</strong></td>
                        <td>${details || 'N/A'}</td>
                        <td>
                            <button class="btn btn-primary" onclick="selectActorForUsername('${actor.id}', '${actor.name}', '${actor.actor_type}')">
                                Manage
                            </button>
                        </td>
                    </tr>
                `;
            });

            tableHTML += '</tbody></table>';
            
            document.getElementById('username-actors-list').innerHTML = tableHTML;
        }

        async function selectActorForUsername(actorId, actorName, actorType) {
            selectedActorForUsername = { id: actorId, name: actorName, actor_type: actorType };  // Changed from 'type' to 'actor_type'
            
            document.getElementById('selected-actor-name').textContent = actorName;
            document.getElementById('username-management-section').style.display = 'block';
            
            // Load existing usernames
            await loadActorUsernames(actorId);
        }

        async function loadActorUsernames(actorId) {
            try {
                const usernames = await supabaseRequest(`v2_actor_usernames?select=*&actor_id=eq.${actorId}&order=platform`);
                
                displayActorUsernames(usernames);
                
            } catch (error) {
                console.error('Error loading usernames:', error);
                document.getElementById('actor-usernames-list').innerHTML = 
                    '<div class="error-message">Error loading usernames</div>';
            }
        }

        function displayActorUsernames(usernames) {
            if (usernames.length === 0) {
                document.getElementById('actor-usernames-list').innerHTML = 
                    '<div class="no-results">No usernames configured for this actor</div>';
                return;
            }

            let html = '<div class="username-list">';
            
            usernames.forEach(un => {
                html += `
                    <div class="username-item">
                        <div class="username-info">
                            <strong>${un.platform}:</strong> @${un.username}
                            ${un.verified ? '<span class="username-badge">✓ Verified</span>' : ''}
                            ${un.is_primary ? '<span class="username-badge">Primary</span>' : ''}
                            ${un.should_scrape ? '<span class="username-badge">Scraping</span>' : ''}
                        </div>
                        <div class="username-actions">
                            <button class="btn btn-secondary" onclick="toggleScrapingUsername('${un.id}', ${!un.should_scrape})">
                                ${un.should_scrape ? 'Disable Scraping' : 'Enable Scraping'}
                            </button>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            
            document.getElementById('actor-usernames-list').innerHTML = html;
        }

        async function addNewUsername() {
            if (!selectedActorForUsername) return;
            
            const platform = document.getElementById('new-username-platform').value;
            const username = document.getElementById('new-username-value').value.trim();
            const verified = document.getElementById('new-username-verified').checked;
            const shouldScrape = document.getElementById('new-username-scrape').checked;
            
            if (!platform || !username) {
                alert('Please select a platform and enter a username');
                return;
            }
            
            try {
                // Insert directly into v2_actor_usernames table
                await supabaseRequest('v2_actor_usernames', {
                    method: 'POST',
                    body: JSON.stringify({
                        actor_id: selectedActorForUsername.id,
                        actor_type: selectedActorForUsername.actor_type,
                        platform: platform,
                        username: username,
                        verified: verified,
                        should_scrape: shouldScrape,
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString()
                    })
                });
                
                // Clear form
                document.getElementById('new-username-platform').value = '';
                document.getElementById('new-username-value').value = '';
                document.getElementById('new-username-verified').checked = false;
                document.getElementById('new-username-scrape').checked = true;
                
                // Reload usernames
                await loadActorUsernames(selectedActorForUsername.id);
                
                alert(`Successfully added ${platform} username: ${username}`);
                
            } catch (error) {
                console.error('Error adding username:', error);
                alert('Error adding username: ' + error.message);
            }
        }

        async function toggleScrapingUsername(usernameId, shouldScrape) {
            try {
                await supabaseRequest(`v2_actor_usernames?id=eq.${usernameId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({
                        should_scrape: shouldScrape,
                        updated_at: new Date().toISOString()
                    })
                });
                
                // Reload usernames
                await loadActorUsernames(selectedActorForUsername.id);
                
            } catch (error) {
                console.error('Error updating username:', error);
                alert('Error updating username: ' + error.message);
            }
        }

        function debouncedSearchActorsForUsernames() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(searchActorsForUsernames, 300);
        }

        async function searchActorsForUsernames() {
            const searchTerm = document.getElementById('username-actor-search').value.toLowerCase().trim();
            
            if (!searchTerm || searchTerm.length < 2) {
                loadActorsForUsernames();
                return;
            }

            try {
                document.getElementById('username-actors-list').innerHTML = '<div class="loading">Searching...</div>';

                const results = await supabaseRequest(`v2_actors?select=*&name.ilike.*${searchTerm}*&order=name&limit=50`);
                
                displayActorsForUsernames(results);

            } catch (error) {
                console.error('Error searching actors:', error);
                document.getElementById('username-actors-list').innerHTML = 
                    `<div class="error-message">Error searching actors: ${error.message}</div>`;
            }
        }

        // Existing actors search for main tab
        function debouncedSearchExistingActors() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(searchExistingActorsMain, 300);
        }

        async function searchExistingActorsMain() {
            const searchTerm = document.getElementById('existing-actors-main-search').value.toLowerCase().trim();
            
            if (!searchTerm || searchTerm.length < 2) {
                existingActorsOffset = 0;
                allExistingActors = [];
                await loadExistingActorsMain();
                return;
            }

            try {
                document.getElementById('existing-actors-main-list').innerHTML = '<div class="loading">Searching...</div>';

                let query = `v2_actors?select=*,primary_relationships:v2_actor_links!actor_links_from_actor_id_fkey(relationship,role,is_primary,to_actor:v2_actors!actor_links_to_actor_id_fkey(id,name,actor_type))&or=(name.ilike.*${searchTerm}*,city.ilike.*${searchTerm}*,state.ilike.*${searchTerm}*)`;
                if (currentActorTypeFilter && currentActorTypeFilter !== 'all') {
                    query += `&actor_type=eq.${currentActorTypeFilter}`;
                }
                query += '&order=name&limit=100';

                const results = await supabaseRequest(query);
                
                // Process results to extract primary relationships
                results.forEach(actor => {
                    if (actor.primary_relationships) {
                        actor.primary_relationship = actor.primary_relationships.find(rel => rel.is_primary === true) || actor.primary_relationships[0];
                        delete actor.primary_relationships;
                    }
                });
                
                allExistingActors = results;
                hasMoreExistingActors = false; // Disable load more for search results
                displayExistingActorsMain(results);

            } catch (error) {
                console.error('Error searching actors:', error);
                document.getElementById('existing-actors-main-list').innerHTML = 
                    `<div class="error-message">Error searching actors: ${error.message}</div>`;
            }
        }

        function filterExistingActorType(type) {
            // Update button states
            document.querySelectorAll('#existing-tab .actor-type-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.closest('.actor-type-btn').classList.add('selected');

            currentActorTypeFilter = type;
            existingActorsOffset = 0;
            allExistingActors = [];
            
            // If there's a search term, run search; otherwise load filtered actors
            const searchTerm = document.getElementById('existing-actors-main-search').value.toLowerCase().trim();
            if (searchTerm && searchTerm.length >= 2) {
                searchExistingActorsMain();
            } else {
                loadExistingActorsMain();
            }
        }

        // Open username modal for a specific actor
        function openUsernameModalForActor(actorId) {
            openManageUsernamesModal();
            
            // After modal opens, find and select the actor
            setTimeout(async () => {
                const actor = existingActors.find(a => a.id === actorId) || 
                             await supabaseRequest(`v2_actors?id=eq.${actorId}&select=*`).then(data => data[0]);
                             
                if (actor) {
                    selectActorForUsername(actor.id, actor.name, actor.actor_type);
                }
            }, 100);
        }

        // Create custom view functions
        function openCreateViewModal() {
            document.getElementById('view-name').value = '';
            document.getElementById('view-description').value = '';
            document.getElementById('view-icon').value = '🔍';
            document.getElementById('filter-type').value = 'keyword';
            document.getElementById('view-message').innerHTML = '';
            
            updateFilterOptions();
            
            document.getElementById('create-view-modal').style.display = 'block';
        }

        function updateFilterOptions() {
            const filterType = document.getElementById('filter-type').value;
            const optionsDiv = document.getElementById('filter-options');
            const combinedDiv = document.getElementById('combined-filters');
            
            let html = '';
            
            if (filterType === 'keyword') {
                html = `
                    <div class="form-group">
                        <label>Keywords (comma separated)</label>
                        <input type="text" id="filter-keywords" placeholder="e.g., tpusa, turning point, charlie kirk">
                    </div>
                `;
                combinedDiv.style.display = 'none';
            } else if (filterType === 'platform') {
                html = `
                    <div class="form-group">
                        <label>Platform</label>
                        <select id="filter-platform">
                            <option value="twitter">Twitter/X</option>
                            <option value="instagram">Instagram</option>
                            <option value="tiktok">TikTok</option>
                            <option value="youtube">YouTube</option>
                            <option value="telegram">Telegram</option>
                            <option value="facebook">Facebook</option>
                        </select>
                    </div>
                `;
                combinedDiv.style.display = 'none';
            } else if (filterType === 'date_range') {
                html = `
                    <div class="form-group">
                        <label>Days Ago</label>
                        <input type="number" id="filter-days" value="7" min="1" max="365">
                    </div>
                `;
                combinedDiv.style.display = 'none';
            } else if (filterType === 'mention_count') {
                html = `
                    <div class="form-group">
                        <label>Minimum Mentions</label>
                        <input type="number" id="filter-min-mentions" value="10" min="1">
                    </div>
                `;
                combinedDiv.style.display = 'none';
            } else if (filterType === 'verified') {
                html = `
                    <div class="form-group">
                        <label>Verification Status</label>
                        <select id="filter-verified">
                            <option value="true">Verified Only</option>
                            <option value="false">Unverified Only</option>
                        </select>
                    </div>
                `;
                combinedDiv.style.display = 'none';
            } else if (filterType === 'combined') {
                html = '<p>Add multiple filters below:</p>';
                combinedDiv.style.display = 'block';
                document.getElementById('filter-list').innerHTML = '';
            }
            
            optionsDiv.innerHTML = html;
        }

        function addFilter() {
            // This would add a new filter to the combined filters list
            // Implementation depends on UI requirements
            alert('Combined filters feature coming soon!');
        }

        async function saveCustomView() {
            const name = document.getElementById('view-name').value.trim();
            const description = document.getElementById('view-description').value.trim();
            const icon = document.getElementById('view-icon').value || '🔍';
            const filterType = document.getElementById('filter-type').value;
            
            if (!name) {
                alert('Please enter a view name');
                return;
            }
            
            // Build filter config
            let filterConfig = { filter: filterType };
            
            if (filterType === 'keyword') {
                const keywords = document.getElementById('filter-keywords').value
                    .split(',')
                    .map(k => k.trim())
                    .filter(k => k);
                if (keywords.length === 0) {
                    alert('Please enter at least one keyword');
                    return;
                }
                filterConfig.keywords = keywords;
                filterConfig.fields = ['detected_username', 'profile_bio', 'profile_displayname'];
            } else if (filterType === 'platform') {
                filterConfig.platform = document.getElementById('filter-platform').value;
            } else if (filterType === 'date_range') {
                filterConfig.days = parseInt(document.getElementById('filter-days').value);
            } else if (filterType === 'mention_count') {
                filterConfig.min_mentions = parseInt(document.getElementById('filter-min-mentions').value);
            } else if (filterType === 'verified') {
                filterConfig.value = document.getElementById('filter-verified').value === 'true';
            }
            
            try {
                await supabaseRequest('actor_classifier_views', {
                    method: 'POST',
                    body: JSON.stringify({
                        name: name,
                        description: description,
                        icon: icon,
                        filter_config: filterConfig,
                        is_system: false,
                        is_active: true
                    })
                });
                
                document.getElementById('view-message').innerHTML = 
                    '<div class="success-message">Custom view created successfully!</div>';
                
                // Reload views
                await loadCustomViews();
                
                setTimeout(() => {
                    closeModal('create-view-modal');
                }, 2000);
                
            } catch (error) {
                console.error('Error creating view:', error);
                document.getElementById('view-message').innerHTML = 
                    '<div class="error-message">Error creating view: ' + error.message + '</div>';
            }
        }

        // Helper functions
        // ============================
        // Network Filter Functions
        // ============================
        
        let allActors = [];
        
        async function loadActorsForSearch() {
            if (allActors.length > 0) return allActors;
            
            try {
                const response = await fetch('/api/actors?limit=1000');
                if (!response.ok) {
                    console.error('Failed to fetch actors:', response.status);
                    return [];
                }
                const data = await response.json();
                allActors = data;
                console.log(`Loaded ${allActors.length} actors for search`);
                return allActors;
            } catch (error) {
                console.error('Error loading actors:', error);
                return [];
            }
        }
        
        async function searchActorsForNetwork(query) {
            clearTimeout(searchTimeout);
            const resultsDiv = document.getElementById('actor-search-results');
            
            if (!query || query.length < 2) {
                resultsDiv.style.display = 'none';
                return;
            }
            
            // If it starts with @, treat it as a direct username
            if (query.startsWith('@')) {
                document.getElementById('network-target-handle').value = query.substring(1);
                document.getElementById('network-target-actor-id').value = '';
                resultsDiv.style.display = 'none';
                return;
            }
            
            searchTimeout = setTimeout(async () => {
                // Load actors if not already loaded
                if (allActors.length === 0) {
                    await loadActorsForSearch();
                    console.log('Loaded actors:', allActors.length);
                }
                
                // Filter actors by name
                const searchLower = query.toLowerCase();
                const matches = allActors.filter(actor => 
                    actor.name && actor.name.toLowerCase().includes(searchLower)
                ).slice(0, 20); // Limit to 20 results
                
                console.log(`Searching for "${query}", found ${matches.length} matches`);
                
                if (matches.length === 0) {
                    resultsDiv.innerHTML = '<div style="padding: 10px; color: #666;">No actors found. Use @username for direct search.</div>';
                    resultsDiv.style.display = 'block';
                    return;
                }
                
                // Build results HTML
                resultsDiv.innerHTML = matches.map(actor => `
                    <div onclick="selectActor('${actor.id}', '${actor.name.replace(/'/g, "\\'")}')" 
                         style="padding: 10px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.2s;"
                         onmouseover="this.style.background='#f5f5f5'" 
                         onmouseout="this.style.background='white'">
                        <div style="font-weight: 500;">${actor.name}</div>
                        <div style="font-size: 12px; color: #666;">
                            ${actor.actor_type} • ${actor.username_count || 0} usernames
                        </div>
                    </div>
                `).join('');
                
                resultsDiv.style.display = 'block';
            }, 300); // Debounce for 300ms
        }
        
        function selectActor(actorId, actorName) {
            document.getElementById('network-target-search').value = actorName;
            document.getElementById('network-target-actor-id').value = actorId;
            document.getElementById('network-target-handle').value = '';
            document.getElementById('actor-search-results').style.display = 'none';
        }
        
        function hideActorResults() {
            document.getElementById('actor-search-results').style.display = 'none';
        }
        
        function toggleNetworkFilter() {
            const filterType = document.getElementById('network-filter-type').value;
            const targetSelector = document.getElementById('network-target-selector');
            const strengthControls = document.getElementById('network-strength-controls');
            const applyBtn = document.getElementById('apply-network-filter-btn');
            const clearBtn = document.getElementById('clear-network-filter-btn');
            
            if (filterType === 'none') {
                targetSelector.style.display = 'none';
                strengthControls.style.display = 'none';
                applyBtn.style.display = 'none';
                clearBtn.style.display = 'none';
                clearNetworkFilter();
            } else {
                targetSelector.style.display = 'flex';
                strengthControls.style.display = 'flex';
                applyBtn.style.display = 'inline-block';
                if (networkFilterActive) {
                    clearBtn.style.display = 'inline-block';
                }
                // Preload actors for faster search
                loadActorsForSearch();
            }
        }
        
        function updateNetworkStrengthLabel() {
            const value = document.getElementById('network-strength-threshold').value;
            document.getElementById('strength-value').textContent = `${value}+ interactions`;
        }
        
        async function applyNetworkFilter() {
            const filterType = document.getElementById('network-filter-type').value;
            const actorId = document.getElementById('network-target-actor-id').value;
            const targetHandle = document.getElementById('network-target-handle').value.trim();
            const searchValue = document.getElementById('network-target-search').value.trim();
            const minInteractions = parseInt(document.getElementById('network-strength-threshold').value);
            
            // If search value starts with @, use it as a username
            if (searchValue.startsWith('@')) {
                document.getElementById('network-target-handle').value = searchValue.substring(1);
            }
            
            // Re-read values after potential update
            const finalActorId = document.getElementById('network-target-actor-id').value;
            const finalHandle = document.getElementById('network-target-handle').value.trim();
            
            if (!finalActorId && !finalHandle) {
                showErrorMessage('Please select an actor or enter @username to filter by');
                return;
            }
            
            const statusDiv = document.getElementById('network-filter-status');
            const messageSpan = document.getElementById('network-filter-message');
            
            statusDiv.style.display = 'block';
            
            // Prepare display text
            let displayText = '';
            if (finalActorId) {
                // Use the search value which contains the actor name
                displayText = searchValue || 'selected actor';
            } else {
                displayText = `@${finalHandle}`;
            }
            messageSpan.textContent = `Loading network connections for ${displayText}...`;
            
            try {
                // Map filter types to API parameter
                const connectionTypeMap = {
                    'connected_to': 'any',
                    'mentioned_by': 'mentioned_by',
                    'mentions': 'mentions',
                    'mutual': 'bidirectional'
                };
                
                // Build query params - use actor_id if available, otherwise target_handle
                const params = {
                    min_interactions: minInteractions,
                    connection_type: connectionTypeMap[filterType] || 'any',
                    limit: 200
                };
                
                if (finalActorId) {
                    params.actor_id = finalActorId;
                } else {
                    params.target_handle = finalHandle;
                }
                
                const response = await fetch(`/api/actors/by_network_strength?` + new URLSearchParams(params));
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.connections || data.connections.length === 0) {
                    messageSpan.textContent = `No actors found with ${minInteractions}+ interactions with @${targetHandle}`;
                    statusDiv.style.background = '#fff3cd';
                    networkFilterActive = false;
                    return;
                }
                
                networkFilterActive = true;
                networkFilterResults = data.connections;
                
                // Update status
                const displayTarget = finalActorId ? searchValue : `@${finalHandle}`;
                messageSpan.innerHTML = `
                    <strong>Network Filter Active:</strong> Showing ${data.connections.length} actors 
                    ${filterType === 'mutual' ? 'with mutual connections to' : 
                      filterType === 'mentioned_by' ? 'who frequently mention' :
                      filterType === 'mentions' ? 'frequently mentioned by' : 
                      'strongly connected to'} 
                    <strong>${displayTarget}</strong> 
                    (${minInteractions}+ interactions)
                `;
                statusDiv.style.background = '#d4edda';
                
                // Show clear button
                document.getElementById('clear-network-filter-btn').style.display = 'inline-block';
                
                // Display the filtered results
                displayNetworkFilteredActors(data.connections);
                
            } catch (error) {
                console.error('Network filter error:', error);
                messageSpan.textContent = `Error loading network data: ${error.message}`;
                statusDiv.style.background = '#f8d7da';
                networkFilterActive = false;
            }
        }
        
        function clearNetworkFilter() {
            networkFilterActive = false;
            networkFilterResults = [];
            
            // Reset UI
            document.getElementById('network-filter-type').value = 'none';
            document.getElementById('network-target-search').value = '';
            document.getElementById('network-target-actor-id').value = '';
            document.getElementById('network-target-handle').value = '';
            document.getElementById('network-strength-threshold').value = '5';
            updateNetworkStrengthLabel();
            
            // Hide controls
            toggleNetworkFilter();
            
            // Hide status
            document.getElementById('network-filter-status').style.display = 'none';
            
            // Reload regular search results
            performUnknownActorSearch();
        }
        
        async function displayNetworkFilteredActors(actors) {
            console.log('displayNetworkFilteredActors called with', actors.length, 'actors');
            
            // Show results container
            document.getElementById('results-container').style.display = 'block';
            
            if (actors.length === 0) {
                document.getElementById('results-content').innerHTML = '<p>No actors found matching the network criteria.</p>';
                document.getElementById('results-title').textContent = 'Network Connected Actors (0)';
                return;
            }
            
            // Show loading while fetching actor data
            document.getElementById('results-content').innerHTML = '<div class="loading">Loading actor details...</div>';
            document.getElementById('results-title').textContent = `Network Connected Actors (${actors.length})`;
            
            try {
                // Fetch the actual unknown actor data for these handles
                const handles = actors.map(a => a.handle);
                const handleFilter = handles.map(h => `detected_username.eq.${h}`).join(',');
                
                // Query v2_unknown_actors for these handles
                const unknownActorsData = await supabaseRequest(
                    `v2_unknown_actors?or=(${handleFilter})&limit=200`
                );
                
                // Create a map for quick lookup
                const unknownActorsMap = {};
                unknownActorsData.forEach(ua => {
                    unknownActorsMap[ua.detected_username] = ua;
                });
                
                // Merge network data with unknown actor data
                const mergedActors = actors.map(actor => {
                    const unknownActor = unknownActorsMap[actor.handle] || {};
                    const hasUnknownActorRecord = !!unknownActor.id;
                    const isLinkedActor = !!actor.actor_id;
                    
                    return {
                        // Use real ID if exists, otherwise a special network ID
                        id: unknownActor.id || (isLinkedActor ? `linked_${actor.actor_id}` : `network_${actor.handle}`),
                        detected_username: actor.handle,
                        platform: unknownActor.platform || 'twitter',
                        mention_count: unknownActor.mention_count || actor.total_interactions || 0,
                        author_count: unknownActor.author_count || actor.mentions_received || 0,
                        profile_displayname: unknownActor.profile_displayname || actor.actor_name || actor.handle,
                        profile_bio: unknownActor.profile_bio || '',
                        first_seen_date: unknownActor.first_seen_date || null,
                        // Mark as 'linked' if it's a known actor, 'network_only' if not in unknown actors
                        review_status: isLinkedActor ? 'linked' : (hasUnknownActorRecord ? unknownActor.review_status : 'network_only'),
                        assigned_actor_id: unknownActor.assigned_actor_id || actor.actor_id,
                        assigned_actor_type: unknownActor.assigned_actor_type || actor.actor_type,
                        // Keep network-specific data
                        network_interactions: actor.total_interactions,
                        network_mentions_given: actor.mentions_given,
                        network_mentions_received: actor.mentions_received,
                        // Flag to indicate this is from network search
                        is_network_result: true,
                        has_unknown_actor_record: hasUnknownActorRecord
                    };
                });
                
                console.log('Merged with unknown actor data:', mergedActors.slice(0, 3));
                
                // Use the existing display function
                displayResults(mergedActors, 'custom', null, false);
                
            } catch (error) {
                console.error('Error loading actor details:', error);
                // Fall back to basic display without bios
                const basicActors = actors.map(actor => ({
                    id: actor.actor_id || `network_${actor.handle}`,
                    detected_username: actor.handle,
                    platform: 'twitter',
                    mention_count: actor.total_interactions || 0,
                    author_count: actor.mentions_received || 0,
                    profile_displayname: actor.actor_name || actor.handle,
                    profile_bio: '',
                    first_seen_date: null,
                    review_status: actor.actor_id ? 'linked' : 'pending',
                    assigned_actor_id: actor.actor_id,
                    assigned_actor_type: actor.actor_type
                }));
                displayResults(basicActors, 'custom', null, false);
            }
        }
        
        function showSuccessMessage(message) {
            document.getElementById('success-message').innerHTML = 
                `<div class="success-message">${message}</div>`;
            document.getElementById('success-message').style.display = 'block';
        }

        function showErrorMessage(message) {
            document.getElementById('success-message').innerHTML = 
                `<div class="error-message">${message}</div>`;
            document.getElementById('success-message').style.display = 'block';
        }

        // Close modal
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            if (event.target.classList.contains('modal')) {
                event.target.style.display = 'none';
            }
        }
        
        // Make functions available globally for onclick handlers
        window.openPromoteModal = openPromoteModal;
        window.selectActorType = selectActorType;
        window.promoteActor = promoteActor;
        window.closeModal = closeModal;
        window.openLinkModal = openLinkModal;
        window.confirmLinkToExisting = confirmLinkToExisting;
        window.selectLinkActor = selectLinkActor;
        window.filterLinkActorType = filterLinkActorType;
        window.toggleAdvancedSearch = toggleAdvancedSearch;
        window.clearAdvancedSearch = clearAdvancedSearch;
        window.performAdvancedActorSearch = performAdvancedActorSearch;
        window.toggleMainAdvancedSearch = toggleMainAdvancedSearch;
        window.performMainAdvancedSearch = performMainAdvancedSearch;
        window.clearMainAdvancedSearch = clearMainAdvancedSearch;
        window.searchMainLinkedActorSuggestions = searchMainLinkedActorSuggestions;
        window.selectMainLinkedActor = selectMainLinkedActor;
        window.searchLinkedActorSuggestions = searchLinkedActorSuggestions;
        window.selectLinkedActor = selectLinkedActor;
        window.loadMoreLinkActors = loadMoreLinkActors;
        window.toggleActorDetails = toggleActorDetails;
        window.toggleSuggestionDetails = toggleSuggestionDetails;
        window.addMetadataField = addMetadataField;
        window.removeMetadataField = removeMetadataField;
        window.updateRelationshipFields = updateRelationshipFields;
        window.addNewMetadataField = addNewMetadataField;
        window.removeNewMetadataField = removeNewMetadataField;
        window.updateNewRelationshipFields = updateNewRelationshipFields;
        window.addPromoteLink = addPromoteLink;
        window.removePromoteLink = removePromoteLink;
        window.addNewLink = addNewLink;
        window.removeNewLink = removeNewLink;
        window.toggleActorLinking = toggleActorLinking;
        window.toggleNewActorLinking = toggleNewActorLinking;
        window.debouncedSearchPromoteLinks = debouncedSearchPromoteLinks;
        window.debouncedSearchNewLinks = debouncedSearchNewLinks;

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            console.log('V2 Actor Management System loaded');
            
            // Add event listeners for tab buttons
            document.getElementById('unknown-tab-btn').addEventListener('click', function() {
                switchTab('unknown');
            });
            document.getElementById('existing-tab-btn').addEventListener('click', function() {
                switchTab('existing');
                // Restore advanced search state when switching to existing tab
                setTimeout(() => restoreAdvancedSearchState(), 100);
            });
            
            // Load custom views
            loadCustomViews();
            
            // Test API connection
            testAPIConnection();
        });
        
        // Test API connection
        async function testAPIConnection() {
            try {
                console.log('🔍 Testing API connection...');
                const testData = await supabaseRequest('v2_unknown_actors?select=id&limit=1');
                console.log('✅ API connection successful');
            } catch (error) {
                console.error('❌ API connection failed:', error);
            }
        }


        // Search for similar actors
        async function searchActors(searchTerm) {
            if (!searchTerm || searchTerm.length < 2) {
                // Clear the dropdown when search is too short
                const select = document.getElementById('link-existing-actor');
                if (select) {
                    select.innerHTML = '<option value="">Type at least 2 characters to search...</option>';
                }
                hideActorPreview();
                return;
            }
            
            try {
                console.log('Searching for actors with term:', searchTerm);
                const result = await callSupabaseFunction('search_similar_v2_actors', {
                    p_search_term: searchTerm,
                    p_bio_text: currentUnknownActor ? currentUnknownActor.profile_bio : null,
                    p_limit: 20
                });
                
                console.log('Search results:', result);
                populateActorDropdown(result || []);
            } catch (error) {
                console.error('Error searching actors:', error);
                const select = document.getElementById('link-existing-actor');
                if (select) {
                    select.innerHTML = '<option value="">Error searching actors. Please try again.</option>';
                }
            }
        }

        // Populate actor dropdown with search results
        function populateActorDropdown(actors) {
            const select = document.getElementById('link-existing-actor');
            select.innerHTML = '<option value="">Select an actor...</option>';
            
            actors.forEach(actor => {
                const option = document.createElement('option');
                option.value = actor.id;
                let text = `${actor.name} (${actor.actor_type})`;
                if (actor.city || actor.state) {
                    text += ` - ${actor.city || ''}, ${actor.state || ''}`;
                }
                
                // Add similarity scores if high
                if (actor.name_similarity > 0.5) {
                    text += ` [Name: ${(actor.name_similarity * 100).toFixed(0)}%]`;
                }
                if (actor.bio_similarity > 0.5) {
                    text += ` [Bio: ${(actor.bio_similarity * 100).toFixed(0)}%]`;
                }
                
                option.textContent = text;
                option.setAttribute('data-actor', JSON.stringify(actor));
                select.appendChild(option);
            });
            
            // Add change event to show preview
            select.onchange = function() {
                const selectedOption = this.options[this.selectedIndex];
                if (selectedOption.value) {
                    const actor = JSON.parse(selectedOption.getAttribute('data-actor'));
                    showActorPreview(actor);
                } else {
                    hideActorPreview();
                }
            };
        }
        
        // Show actor preview
        function showActorPreview(actor) {
            const preview = document.getElementById('actor-preview');
            preview.innerHTML = `
                <strong>${actor.name}</strong> (${actor.actor_type})<br>
                ${actor.city || actor.state ? `Location: ${actor.city || ''}, ${actor.state || ''}<br>` : ''}
                ${actor.about ? `About: ${actor.about.substring(0, 150)}${actor.about.length > 150 ? '...' : ''}<br>` : ''}
                ${actor.existing_usernames ? `Usernames: ${actor.existing_usernames.map(u => `@${u.username} (${u.platform})`).join(', ')}` : ''}
            `;
            preview.style.display = 'block';
        }
        
        // Hide actor preview
        function hideActorPreview() {
            const preview = document.getElementById('actor-preview');
            preview.style.display = 'none';
        }

        // Loading indicator functions
        function showLoading() {
            // Create loading overlay if it doesn't exist
            let loadingOverlay = document.getElementById('loading-overlay');
            if (!loadingOverlay) {
                loadingOverlay = document.createElement('div');
                loadingOverlay.id = 'loading-overlay';
                loadingOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
                loadingOverlay.innerHTML = `
                    <div style="background: white; padding: 20px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 10px;">⏳</div>
                        <div>Loading...</div>
                    </div>
                `;
                document.body.appendChild(loadingOverlay);
            }
            loadingOverlay.style.display = 'flex';
        }
        
        function hideLoading() {
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
        }

        // Call Supabase function helper
        async function callSupabaseFunction(functionName, params) {
            console.log(`Calling function ${functionName} with params:`, params);
            const result = await supabaseRequest(`rpc/${functionName}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(params)
            });
            console.log(`Function ${functionName} returned:`, result);
            return result;
        }

        // Merge Duplicates Functions
        let duplicateGroups = [];
        let selectedMergeGroup = null;
        let duplicateTypeFilter = 'all';
        
        async function openMergeDuplicatesModal() {
            document.getElementById('merge-duplicates-modal').style.display = 'block';
            await findDuplicates();
        }
        
        async function findDuplicates() {
            try {
                showLoading();
                
                // Query v2_actors to find potential duplicates
                let query = 'v2_actors?select=id,name,actor_type,city,state,about';
                
                // Add type filter if not 'all'
                if (duplicateTypeFilter !== 'all') {
                    query += `&actor_type=eq.${duplicateTypeFilter}`;
                }
                
                query += '&order=name';
                
                const response = await fetch(`${SUPABASE_URL}/rest/v1/${query}`, {
                    headers: {
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch actors');
                }
                
                const actors = await response.json();
                
                // Group actors by similar names
                const groups = findSimilarActorGroups(actors);
                duplicateGroups = groups;
                
                displayDuplicateGroups(groups);
                
            } catch (error) {
                console.error('Error finding duplicates:', error);
                alert('Error finding duplicates: ' + error.message);
            } finally {
                hideLoading();
            }
        }
        
        function findSimilarActorGroups(actors) {
            const groups = [];
            const processed = new Set();
            
            for (let i = 0; i < actors.length; i++) {
                if (processed.has(actors[i].id)) continue;
                
                const group = [actors[i]];
                processed.add(actors[i].id);
                
                // Find similar actors
                for (let j = i + 1; j < actors.length; j++) {
                    if (processed.has(actors[j].id)) continue;
                    
                    // Check for similarity
                    if (areSimilarActors(actors[i], actors[j])) {
                        group.push(actors[j]);
                        processed.add(actors[j].id);
                    }
                }
                
                // Only add groups with duplicates
                if (group.length > 1) {
                    groups.push(group);
                }
            }
            
            return groups;
        }
        
        function areSimilarActors(actor1, actor2) {
            // Check name similarity
            const name1 = actor1.name.toLowerCase().trim();
            const name2 = actor2.name.toLowerCase().trim();
            
            // Exact match
            if (name1 === name2) return true;
            
            // Check if one contains the other
            if (name1.includes(name2) || name2.includes(name1)) return true;
            
            // Check similarity score
            const similarity = calculateSimilarity(name1, name2);
            if (similarity > 0.8) return true;
            
            // Check if they're in same location with similar names
            if (actor1.city === actor2.city && actor1.state === actor2.state && similarity > 0.6) {
                return true;
            }
            
            return false;
        }
        
        function calculateSimilarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            
            if (longer.length === 0) return 1.0;
            
            const editDistance = getEditDistance(longer, shorter);
            return (longer.length - editDistance) / parseFloat(longer.length);
        }
        
        function getEditDistance(str1, str2) {
            const matrix = [];
            
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }
        
        let displayedGroups = []; // Track currently displayed groups
        
        function displayDuplicateGroups(groups) {
            const container = document.getElementById('duplicate-groups');
            
            // Store the groups being displayed
            displayedGroups = groups;
            
            if (groups.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666;">No duplicate groups found.</p>';
                return;
            }
            
            let html = '<div style="padding: 10px;">';
            html += `<p style="margin-bottom: 10px;"><strong>Found ${groups.length} potential duplicate groups:</strong></p>`;
            
            groups.forEach((group, index) => {
                html += `
                    <div class="duplicate-group" style="margin-bottom: 15px; padding: 15px; border: 1px solid #ddd; border-radius: 8px; background: #f9f9f9;">
                        <h4 style="margin-bottom: 10px;">Group ${index + 1} (${group.length} actors)</h4>
                        <div style="display: grid; gap: 10px;">
                `;
                
                group.forEach(actor => {
                    const location = [actor.city, actor.state].filter(Boolean).join(', ') || 'No location';
                    html += `
                        <div style="padding: 8px; background: white; border-radius: 5px; display: flex; justify-content: space-between;">
                            <div>
                                <strong>${actor.name}</strong> 
                                <span style="color: #666;">(${actor.actor_type})</span>
                                <br>
                                <small style="color: #999;">${location}</small>
                            </div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                        <button class="btn btn-primary" style="margin-top: 10px;" onclick="selectMergeGroup(${index})">
                            Select for Merge
                        </button>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        async function selectMergeGroup(groupIndex) {
            // Use the displayed groups (which might be filtered) instead of the full list
            selectedMergeGroup = displayedGroups[groupIndex];
            
            // Show merge action area
            document.getElementById('merge-action-area').style.display = 'block';
            
            // Fetch full details for each actor in the group
            showLoading();
            try {
                const detailedActors = [];
                
                for (const actor of selectedMergeGroup) {
                    // Fetch complete actor data including usernames and relationships
                    const [usernamesResp, relationshipsResp, eventsResp] = await Promise.all([
                        // Get usernames
                        fetch(`${SUPABASE_URL}/rest/v1/v2_actor_usernames?actor_id=eq.${actor.id}`, {
                            headers: {
                                'apikey': SUPABASE_KEY,
                                'Authorization': `Bearer ${SUPABASE_KEY}`
                            }
                        }),
                        // Get relationships (using correct table name)
                        fetch(`${SUPABASE_URL}/rest/v1/v2_actor_links?or=(from_actor_id.eq.${actor.id},to_actor_id.eq.${actor.id})`, {
                            headers: {
                                'apikey': SUPABASE_KEY,
                                'Authorization': `Bearer ${SUPABASE_KEY}`
                            }
                        }),
                        // Get event count (using correct table name)
                        fetch(`${SUPABASE_URL}/rest/v1/v2_event_actor_links?actor_id=eq.${actor.id}&select=event_id`, {
                            headers: {
                                'apikey': SUPABASE_KEY,
                                'Authorization': `Bearer ${SUPABASE_KEY}`,
                                'Prefer': 'count=exact',
                                'Range': '0-0'
                            }
                        })
                    ]);
                    
                    // Parse responses with error handling
                    const usernames = usernamesResp.ok ? await usernamesResp.json() : [];
                    const relationships = relationshipsResp.ok ? await relationshipsResp.json() : [];
                    const eventCount = eventsResp.ok ? 
                        (eventsResp.headers.get('content-range')?.split('/')[1] || '0') : '0';
                    
                    detailedActors.push({
                        ...actor,
                        usernames: usernames,
                        relationships: relationships,
                        event_count: eventCount
                    });
                }
                
                // Store detailed actors for manipulation
                selectedMergeGroup = detailedActors;
                
                // Display the group
                displaySelectedMergeGroup();
                
                // Scroll to merge area
                document.getElementById('merge-action-area').scrollIntoView({ behavior: 'smooth' });
                
            } catch (error) {
                console.error('Error loading actor details:', error);
                alert('Error loading actor details: ' + error.message);
            } finally {
                hideLoading();
            }
        }
        
        function displaySelectedMergeGroup() {
            if (!selectedMergeGroup || selectedMergeGroup.length === 0) {
                document.getElementById('merge-action-area').style.display = 'none';
                return;
            }
            
            const groupDisplay = document.getElementById('selected-merge-group');
            let html = '<div style="display: grid; gap: 15px; margin-bottom: 10px;">';
            
            // Add "Add Actor" button at the top
            html += `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #e8f4fd; border: 1px dashed #4facfe; border-radius: 8px;">
                    <div style="flex: 1;">
                        <strong>Add Actor to Group:</strong>
                        <input type="text" 
                               id="add-actor-search" 
                               placeholder="Search for actor by name or username..." 
                               style="width: calc(100% - 120px); margin: 0 10px; padding: 8px; border: 1px solid #ddd; border-radius: 5px;"
                               onkeyup="searchActorsToAdd(this.value)">
                        <button class="btn btn-primary" onclick="showAddActorResults()" style="padding: 8px 15px;">
                            🔍 Search
                        </button>
                    </div>
                </div>
                <div id="add-actor-results" style="display: none; max-height: 200px; overflow-y: auto; padding: 10px; background: #f9f9f9; border: 1px solid #ddd; border-radius: 5px;">
                    <!-- Search results will appear here -->
                </div>
            `;
            
            selectedMergeGroup.forEach((actor, index) => {
                    const location = [actor.city, actor.state].filter(Boolean).join(', ') || 'No location';
                    
                    // Format usernames with profile links
                    const usernamesHtml = actor.usernames && actor.usernames.length > 0 
                        ? actor.usernames.map(u => {
                            let profileUrl = '';
                            if (u.platform === 'twitter') {
                                profileUrl = `https://twitter.com/${u.username}`;
                            } else if (u.platform === 'instagram') {
                                profileUrl = `https://instagram.com/${u.username}`;
                            } else if (u.platform === 'tiktok') {
                                profileUrl = `https://tiktok.com/@${u.username}`;
                            } else if (u.platform === 'youtube') {
                                profileUrl = `https://youtube.com/@${u.username}`;
                            } else if (u.platform === 'truth_social') {
                                profileUrl = `https://truthsocial.com/@${u.username}`;
                            }
                            
                            if (profileUrl) {
                                return `<a href="${profileUrl}" target="_blank" style="color: #007bff; text-decoration: none;">@${u.username}</a> (${u.platform}${u.verified ? ' ✓' : ''})`;
                            } else {
                                return `@${u.username} (${u.platform}${u.verified ? ' ✓' : ''})`;
                            }
                        }).join(', ')
                        : 'No usernames';
                    
                    // Format relationships (handle both joined and non-joined data)
                    const relationshipsHtml = actor.relationships && actor.relationships.length > 0
                        ? actor.relationships.map(r => {
                            if (r.from_actor_id === actor.id) {
                                // This actor is the source of the relationship
                                const targetName = r.to_actor?.name || r.to_actor_id || 'Unknown';
                                return `${r.relationship} → ${targetName}`;
                            } else {
                                // This actor is the target of the relationship
                                const sourceName = r.from_actor?.name || r.from_actor_id || 'Unknown';
                                return `${sourceName} → ${r.relationship}`;
                            }
                        }).join('<br>')
                        : 'No relationships';
                    
                    html += `
                        <div style="padding: 15px; background: white; border: 2px solid #ddd; border-radius: 8px; position: relative;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                                <div>
                                    <strong style="font-size: 16px; color: #333;">${actor.name}</strong>
                                    <span style="background: #f0f0f0; padding: 2px 8px; border-radius: 4px; margin-left: 10px; font-size: 12px;">
                                        ${actor.actor_type}
                                    </span>
                                </div>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <span style="background: #4facfe; color: white; padding: 4px 10px; border-radius: 4px; font-size: 12px;">
                                        Actor #${index + 1}
                                    </span>
                                    <button onclick="removeFromMergeGroup('${actor.id}')" 
                                            style="background: #ff4444; color: white; border: none; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;"
                                            title="Remove from merge group">
                                        ✕ Remove
                                    </button>
                                </div>
                            </div>
                            
                            <div style="display: grid; gap: 8px; font-size: 14px;">
                                <div>
                                    <strong>ID:</strong> <code style="background: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-size: 11px;">${actor.id}</code>
                                </div>
                                
                                <div>
                                    <strong>Location:</strong> ${location}
                                </div>
                                
                                <div>
                                    <strong>Events:</strong> ${actor.event_count} events linked
                                </div>
                                
                                <div>
                                    <strong>Usernames:</strong> ${usernamesHtml}
                                </div>
                                
                                ${actor.relationships && actor.relationships.length > 0 ? `
                                <div>
                                    <strong>Relationships:</strong><br>
                                    <div style="margin-left: 20px; color: #666; font-size: 13px;">
                                        ${relationshipsHtml}
                                    </div>
                                </div>
                                ` : ''}
                                
                                ${actor.about ? `
                                <div>
                                    <strong>About:</strong><br>
                                    <div style="margin-left: 20px; color: #666; font-style: italic;">
                                        ${actor.about}
                                    </div>
                                </div>
                                ` : ''}
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                html += `
                    <div style="padding: 10px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 5px; margin-top: 10px;">
                        <strong>⚠️ Important:</strong> When you merge, all events, posts, relationships, and usernames from the other actors will be transferred to the master actor. The other actors will be permanently deleted.
                    </div>
                `;
                groupDisplay.innerHTML = html;
                
                // Populate master select with detailed info
                const masterSelect = document.getElementById('master-actor-select');
                masterSelect.innerHTML = '<option value="">Select master actor...</option>';
                
                selectedMergeGroup.forEach((actor, index) => {
                    const option = document.createElement('option');
                    option.value = actor.id;
                    const location = [actor.city, actor.state].filter(Boolean).join(', ') || 'No location';
                    const usernameCount = actor.usernames ? actor.usernames.length : 0;
                    option.textContent = `Actor #${index + 1}: ${actor.name} (${actor.actor_type}) - ${location} - ${actor.event_count} events, ${usernameCount} usernames`;
                    masterSelect.appendChild(option);
                });
        }
        
        // Remove actor from merge group
        function removeFromMergeGroup(actorId) {
            if (!selectedMergeGroup || selectedMergeGroup.length <= 2) {
                alert('You need at least 2 actors to merge');
                return;
            }
            
            // Remove the actor from the group
            selectedMergeGroup = selectedMergeGroup.filter(a => a.id !== actorId);
            
            // Refresh the display
            displaySelectedMergeGroup();
        }
        
        // Search for actors to add to merge group
        let searchActorsTimer = null;
        function searchActorsToAdd(searchTerm) {
            clearTimeout(searchActorsTimer);
            searchActorsTimer = setTimeout(() => {
                if (searchTerm && searchTerm.length >= 2) {
                    showAddActorResults();
                }
            }, 300);
        }
        
        async function showAddActorResults() {
            const searchTerm = document.getElementById('add-actor-search').value.trim();
            if (!searchTerm || searchTerm.length < 2) {
                alert('Please enter at least 2 characters to search');
                return;
            }
            
            try {
                // Search for actors
                let query = `v2_actors?select=id,name,actor_type,city,state,about`;
                query += `&or=(name.ilike.*${searchTerm}*,city.ilike.*${searchTerm}*,state.ilike.*${searchTerm}*)`;
                query += '&limit=20';
                
                const response = await fetch(`${SUPABASE_URL}/rest/v1/${query}`, {
                    headers: {
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to search actors');
                }
                
                const actors = await response.json();
                
                // Filter out actors already in the group
                const existingIds = selectedMergeGroup.map(a => a.id);
                const availableActors = actors.filter(a => !existingIds.includes(a.id));
                
                // Display results
                const resultsDiv = document.getElementById('add-actor-results');
                if (availableActors.length === 0) {
                    resultsDiv.innerHTML = '<p style="color: #666;">No actors found or all results are already in the group</p>';
                } else {
                    let html = '<p style="margin: 0 0 10px 0;"><strong>Select actor to add:</strong></p>';
                    html += '<div style="display: grid; gap: 5px;">';
                    
                    availableActors.forEach(actor => {
                        const location = [actor.city, actor.state].filter(Boolean).join(', ') || 'No location';
                        html += `
                            <div style="padding: 8px; background: white; border: 1px solid #ddd; border-radius: 5px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong>${actor.name}</strong> (${actor.actor_type})
                                    <br><small style="color: #666;">${location}</small>
                                </div>
                                <button onclick="addToMergeGroup('${actor.id}')" 
                                        style="background: #28a745; color: white; border: none; padding: 4px 10px; border-radius: 4px; cursor: pointer;">
                                    + Add
                                </button>
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                    resultsDiv.innerHTML = html;
                }
                resultsDiv.style.display = 'block';
                
            } catch (error) {
                console.error('Error searching actors:', error);
                alert('Error searching actors: ' + error.message);
            }
        }
        
        // Add actor to merge group
        async function addToMergeGroup(actorId) {
            try {
                // Fetch full details for the actor
                showLoading();
                
                // Get the actor details
                const actorResp = await fetch(`${SUPABASE_URL}/rest/v1/v2_actors?id=eq.${actorId}`, {
                    headers: {
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`
                    }
                });
                
                if (!actorResp.ok) {
                    throw new Error('Failed to fetch actor details');
                }
                
                const actors = await actorResp.json();
                if (actors.length === 0) {
                    throw new Error('Actor not found');
                }
                
                const actor = actors[0];
                
                // Fetch additional details (usernames, relationships, events)
                const [usernamesResp, relationshipsResp, eventsResp] = await Promise.all([
                    fetch(`${SUPABASE_URL}/rest/v1/v2_actor_usernames?actor_id=eq.${actor.id}`, {
                        headers: {
                            'apikey': SUPABASE_KEY,
                            'Authorization': `Bearer ${SUPABASE_KEY}`
                        }
                    }),
                    fetch(`${SUPABASE_URL}/rest/v1/v2_actor_links?or=(from_actor_id.eq.${actor.id},to_actor_id.eq.${actor.id})`, {
                        headers: {
                            'apikey': SUPABASE_KEY,
                            'Authorization': `Bearer ${SUPABASE_KEY}`
                        }
                    }),
                    fetch(`${SUPABASE_URL}/rest/v1/v2_event_actor_links?actor_id=eq.${actor.id}&select=event_id`, {
                        headers: {
                            'apikey': SUPABASE_KEY,
                            'Authorization': `Bearer ${SUPABASE_KEY}`,
                            'Prefer': 'count=exact',
                            'Range': '0-0'
                        }
                    })
                ]);
                
                const usernames = usernamesResp.ok ? await usernamesResp.json() : [];
                const relationships = relationshipsResp.ok ? await relationshipsResp.json() : [];
                const eventCount = eventsResp.ok ? 
                    (eventsResp.headers.get('content-range')?.split('/')[1] || '0') : '0';
                
                // Add to group
                selectedMergeGroup.push({
                    ...actor,
                    usernames: usernames,
                    relationships: relationships,
                    event_count: eventCount
                });
                
                // Hide search results
                document.getElementById('add-actor-results').style.display = 'none';
                document.getElementById('add-actor-search').value = '';
                
                // Refresh display
                displaySelectedMergeGroup();
                
                hideLoading();
                
            } catch (error) {
                console.error('Error adding actor to group:', error);
                alert('Error adding actor to group: ' + error.message);
                hideLoading();
            }
        }
        
        function cancelMerge() {
            selectedMergeGroup = null;
            document.getElementById('merge-action-area').style.display = 'none';
        }
        
        async function executeMerge() {
            const masterActorId = document.getElementById('master-actor-select').value;
            
            if (!masterActorId) {
                alert('Please select a master actor');
                return;
            }
            
            if (!confirm('Are you sure you want to merge these actors? This action cannot be undone.')) {
                return;
            }
            
            try {
                showLoading();
                
                // Get actors to merge (excluding master)
                const actorsToMerge = selectedMergeGroup
                    .filter(a => a.id !== masterActorId)
                    .map(a => a.id);
                
                try {
                    // Try the full merge function first
                    const result = await callSupabaseFunction('merge_v2_actors', {
                        p_master_actor_id: masterActorId,
                        p_actor_ids_to_merge: actorsToMerge
                    });
                    
                    alert(`Successfully merged ${actorsToMerge.length} actors!`);
                } catch (error) {
                    // If timeout error, fall back to step-by-step approach
                    if (error.message && (error.message.includes('timeout') || error.message.includes('57014'))) {
                        console.log('Merge timed out, using step-by-step approach...');
                        
                        // Update loading message
                        const loadingEl = document.querySelector('.loading-overlay .loading-content');
                        if (loadingEl) {
                            loadingEl.innerHTML = '<div class="spinner"></div><p>Merge timed out. Running step-by-step merge...</p>';
                        }
                        
                        // Execute steps sequentially
                        const steps = [
                            { name: 'merge_v2_actors_step1_events', label: 'Migrating event links...' },
                            { name: 'merge_v2_actors_step2_posts', label: 'Migrating post links...' },
                            { name: 'merge_v2_actors_step3_relationships', label: 'Migrating actor relationships...' },
                            { name: 'merge_v2_actors_step4_usernames', label: 'Migrating usernames...' },
                            { name: 'merge_v2_actors_step5_finalize', label: 'Finalizing merge...' }
                        ];
                        
                        for (const step of steps) {
                            if (loadingEl) {
                                loadingEl.innerHTML = `<div class="spinner"></div><p>${step.label}</p>`;
                            }
                            
                            try {
                                await callSupabaseFunction(step.name, {
                                    p_master_actor_id: masterActorId,
                                    p_actor_ids_to_merge: actorsToMerge
                                });
                                console.log(`Completed: ${step.label}`);
                            } catch (stepError) {
                                console.error(`Error in ${step.name}:`, stepError);
                                throw new Error(`Failed at step: ${step.label} - ${stepError.message}`);
                            }
                        }
                        
                        alert(`Successfully merged ${actorsToMerge.length} actors using step-by-step approach!`);
                    } else {
                        // Re-throw if not a timeout error
                        throw error;
                    }
                }
                
                // Reset and refresh
                cancelMerge();
                await findDuplicates();
                
            } catch (error) {
                console.error('Error merging actors:', error);
                alert('Error merging actors: ' + error.message);
            } finally {
                hideLoading();
            }
        }
        
        function filterDuplicateType(type) {
            duplicateTypeFilter = type;
            
            // Update button states
            document.querySelectorAll('#merge-duplicates-modal .actor-type-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.type === type);
            });
            
            // Refresh duplicates
            findDuplicates();
        }
        
        async function searchDuplicates() {
            const searchTerm = document.getElementById('duplicate-search').value.toLowerCase().trim();
            
            if (!searchTerm) {
                displayDuplicateGroups(duplicateGroups);
                return;
            }
            
            // Filter groups to those containing the search term
            const filteredGroups = duplicateGroups.filter(group => 
                group.some(actor => 
                    actor.name.toLowerCase().includes(searchTerm) ||
                    (actor.city && actor.city.toLowerCase().includes(searchTerm)) ||
                    (actor.state && actor.state.toLowerCase().includes(searchTerm))
                )
            );
            
            displayDuplicateGroups(filteredGroups);
        }
    </script>
</body>
</html>